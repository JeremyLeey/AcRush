[toc]

# 单源最短路径Dijstra模板

适用于边权为正的情况，有向图无向图都ojbk(假设起点为0)

```
清除所有点标号
d[s] = 0, 其余d[i] = INF;
循环n次{
  在所有未标记的点中,挑选一个d值最小的点x
  给结点x标记
  对于从x出发的所有边,更新d[y] = min(d[y], d[x] + w(x, y));
}

void Dijstra(int s) {
	memset(vis, 0, sizeof vis);
	for (int i = 0; i < n; i++) d[i] = inf;
	d[s] = 0;
	for (int i = 0; i < n; i++) {
		int x, m = inf;
		for (int j = 0; j < n; j++) {
			if (!v[j] && d[j] < m) {
				m = d[j];
				x = j;
			}
		}
		vis[x] = 1;
		for (int j = 0; j < n; j++) {
			d[j] = min(d[j], d[x] + w[x][j]);
		}
	}
}
```

复杂度O(n2),利用优先队列优化可以将复杂度优化到O(mlogn),极限情况m和n2是同阶的，但大多数情况下图都是稀疏的，m远小于n2。

常见优化：使用vector存储邻接链表存储图，使用优先队列实现find min d[i]步骤；

虽然在最短路问题中，每条边只有边权这一个属性，但后面的最大流以及最小费用流中还会出现容量，流量以及费用等属性。所以在这里使用一个称为Edge的结构体，这会让这里的代码与后面的代码在风格上更统一。

```
struct Edge{
	int from, to, dist;
	Edge(int u, int v, int d): from(u),to(v),dist(d) {}
};

struct Node{
	int d, u;
	bool operaotr < (const Node& rhs) const {
		return d > rhs.d;
	}
};

struct Dijstra {
	int n, m;
	vector<Edge> G[maxn]; //  邻接链表
	bool vis[maxn];
	int d[maxn];
	int p[maxn];
	
	void init(int n) {
		this->n = n;
		for (int i = 0; i < n; i++) G[i].clear();
	}
	
	void addEdge(int u, int v, int dist) {
		// 无向图两边都要push 有向图只有一边
		G[u].push_back(Edge(u, v, dist));
		G[v].push_back(Edge(v, u, dist));
	}
	
	void Dijstra(int s) {
		priority_queue<Node> Q;
		for (int i = 0; i < n; i++) d[i] = INF;
		d[s] = 0;
		memset(vis, 0, sizeof vis);
		Q.push((Node){0, s});
		while (!Q.empty()) {
			Node curr = Q.top(); Q.pop();
			int u = curr.u;
			if (vis[u]) continue;
			vis[u] = true;
			for (int i = 0; i < G[u].size(); i++) {
				Edge e = G[u][i];
				if (d[e.to] > d[u] + e.dist) {
					d[e.to] = d[u] + e.dist;
					Q.push((Node){d[e.to], e.to});
				}
			}
		}
	}
};
```

在松弛成功后，需要修改节点e.to的优先级，但STL中的优先队列不提供修改优先级的操作。因此，只能将新元素重新插入优先队列，这样做并不会影响结果的正确性，因为d值小的节点自然会先出队列。为了防止节点的重复扩展，如果发现新取出来的节点曾经已经被访问过vis[u]，应该直接把它扔掉。

# Bellman-Ford算法

当负权存在时，连最短路都不一定存在了。尽管如此，还是有办法在最短路存在的情况下把它求出来。首先，如果最短路存在，则一定存在一个不含环的最短路。既然不含环,最短路最多只经过不算起点的n-1个结点，可以通过n-1轮松弛操作得到，比如(假设起点为0)

```
for (int i = 0; i < n; i++) d[i] = INF;
d[0] = 0;
for (int k = 0; k < n-1; k++) {
	// 迭代n-1次
	for (int i = 0; i < m; i++) {
		// 检查每条边
		int x = u[i], y = v[i];
		if (d[x] < INF) {
			d[y] = min(d[y], d[x]+w[i]); // 松弛
		}
	}
}
```

时间复杂度O(nm),在实践中，常常用FIFO队列来代替上面的循环检查，像这样

```
bool bellman_ford(int s) {
	queue<int> Q;
	memset(inq, 0, sizeof inq); // inq[i]-点i是否在队列中
	memset(cnt, 0, sizeof cnt); // cnt[i]-点i的入队次数
	for (int i = 0; i < n; i++) d[i] = INF;
	d[s] = 0;
	inq[s] = true;
	Q.push(s);
	while (!Q.empty()) {
		int u = Q.front(); Q.pop();
		inq[u] = false;
		for (int i = 0; i < G[u].size(); i++) {
			Edge &e = edges[G[u][i]];
			if (d[u] < INF && d[e.to] > d[u] + e.dist) {
				d[e.to] = d[u] + e.dist;
				p[e.to] = G[u][i];
				if (!inq[e.to]) {
					Q.push(e.to);
					inq[e.to] = true;
					if (++cnt[e.to] > n) {
						return false; // 存在负环
					}
				}
			}
		}
	}
	return true;
}
```

# 多源最短路径Floyd-Warshall模板

```
思想是动态规划：从i到j只经过前k个结点的最短路径为加入第k个节点后是否存在一条从i到k再到j更短的路
d[i][j][k] = max(d[i][j][k-1], d[i][k][k-1] + d[k][j][k-1]);
利用滚动数组优化如下：
for (int k = 0; k < n; k++)
	for (int i = 0; i < n; i++)
		for (int j = 0; j < n; j++) 
			d[i][j] = max(d[i][j], d[i][k] + d[k][i]);
初始化d[i][i] = 0, 其余d=inf.
```

# 有向图的传递闭包

在有向图中，有时不必关心路径的长度，而只关心两点间是否有通路，则可以用1和0表示连通和不连通。主算法中相应改成

```
d[i][j] = d[i][j] || (d[i][k] && d[k][j])
```

这样的结果称为有向图的传递闭包

# 20.2.24 POJ -2387 Til the Cows Come Home 最短路裸题

```
#include <cstdio>
#include <queue>
#include <cstring>
#include <algorithm>

using namespace std;

const int maxn = 1005;
const int inf = 0x3f3f3f3f;

int t, n, m[maxn][maxn];
int d[maxn], vis[maxn];

void Dijstra(int s) {
	for (int i = 1; i <= n; i++) {
		d[i] = inf;
		vis[i] = 0;
	}
	d[s] = 0;
	for (int i = 0; i < n; i++) {
		int p = -1, minp = inf;
		for (int j = 1; j <= n; j++) {
			if (!vis[j] && d[j] < minp) {
				minp = d[j];
				p = j;
			}
		}
		if (p == -1) return;
		vis[p] = 1;
		for (int j = 1; j <= n; j++) {
			d[j] = min(d[j], d[p] + m[p][j]);
		}
	}
}

int main() {
	while (~scanf("%d %d", &t, &n)) {
		for (int i = 1; i <= n; i++) {
			for (int j = 1; j <= n; j++) {
				m[i][j] = inf;
			}
		}
		for (int i = 0; i < t; i++) {
			int u, v, d;
			scanf("%d %d %d", &u, &v, &d);
			// 题目可能会给重复边
			m[u][v] = m[v][u] = min(m[u][v], d);
		}
		Dijstra(n);
		printf("%d\n", d[1]);
	}
}

```

换用邻接链表以及使用优先队列优化

```
#include <cstdio>
#include <queue>
#include <cstring>
#include <algorithm>

using namespace std;

const int maxn = 1005;
const int inf = 0x3f3f3f3f;

int t, n;
int d[maxn], vis[maxn];

struct Edge {
	int from, to, dist;
	Edge(int u, int v, int d) : from(u), to(v), dist(d) {}
};

struct Node {
	int d, u;
	bool operator < (const Node& rhs) const {
		return d > rhs.d;
	}
	Node(int d_, int u_) :d(d_), u(u_) {}
};

vector<Edge> G[maxn];

void Dijstra(int s) {
	priority_queue<Node> q;
	for (int i = 1; i <= n; i++) d[i] = inf;
	d[s] = 0;
	memset(vis, 0, sizeof vis);
	q.push(Node(0, s));
	while (!q.empty()) {
		Node curr = q.top(); q.pop();
		int u = curr.u;
		if (vis[u]) continue;
		vis[u] = true;
		for (int i = 0; i < G[u].size(); i++) {
			Edge v = G[u][i];
			if (d[v.to] > d[u] + v.dist) {
				d[v.to] = d[u] + v.dist;
				q.push(Node(d[v.to], v.to));
			}
		}
	}
}

int main() {
	while (~scanf("%d %d", &t, &n)) {
		for (int i = 1; i <= n; i++) G[i].clear();
		for (int i = 0; i < t; i++) {
			int u, v, d;
			scanf("%d %d %d", &u, &v, &d);
			G[u].push_back(Edge(u, v, d));
			G[v].push_back(Edge(v, u, d));
		}
		Dijstra(n);
		printf("%d\n", d[1]);
	}
}
```

# 20.2.24 POJ-2253 Frogger 最大值最小化二分的Floyd传递闭包 or 变形的Dijstra

给你n个点的坐标同时告诉你起点s与终点t,从s到t有很多种路可以走，一条路有很多边组成，记d是一种路中的最大边，求d的最小值。

**方法一**

最大值最小化问题常用二分解决，本题也可以。对边的长度进行二分，对于当前中值m来说，判断从起点s到终点t的可连通性，采用floyd传递闭包即可解决。注意这里的边长最好全部用int处理，直到之后输出时才求其根号。本题我用double变量进行二分，精度选的很小时直接TLE，选得稍微大一点才勉强A过。

```c++
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>

using namespace std;

const int maxn = 205;
const int inf = 0x3f3f3f3f;
int n;
int x[maxn], y[maxn];
int d[maxn][maxn], dis[maxn][maxn];

bool floyd(int m) {

	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= n; j++) {
			d[i][j] = dis[i][j] > m ? 0 : 1;
		}
	}

	for (int k = 1; k <= n; k++) {
		for (int i = 1; i <= n; i++) {
			for (int j = 1; j <= n; j++) {
				d[i][j] = d[i][j] || (d[i][k] && d[k][j]);
				if (d[1][2]) return true;
			}
		}
	}

	return false;
}
int main() {
	// freopen("E://input.txt", "r", stdin);
	int kase = 0;
	while (~scanf("%d", &n) && n) {
		kase++;
		for (int i = 1; i <= n; i++) {
			scanf("%d %d", &x[i], &y[i]);
		}
		for (int i = 1; i <= n; i++) {
			for (int j = 1; j <= n; j++) {
				dis[i][j] = dis[j][i] = (x[i] - x[j])*(x[i] - x[j]) + (y[i] - y[j])*(y[i] - y[j]);
			}
		}

		int l = 0, r = 2000005, m = 0;
		while (r > l) {
			m = (l + r) / 2;
			// 在m距离下判断1和2号点是否连通
			if (floyd(m)) {
				r = m;
			}
			else {
				l = m+1;
			}
		}
		printf("Scenario #%d\n", kase);
		printf("Frog Distance = %.3f\n", sqrt((double)l));
		puts("");
	}
	return 0;
}
```

**方法二**

由于起点终点均已告诉，所以可以直接用Dijstra解决。Dijstra中d[i]的含义则变成从起点s到终点i时不同路径的边的最大值的最小值，起初d[i] = Distance(s, i)。在松弛阶段修改相应条件即可。

```C++
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>

using namespace std;

const int maxn = 205;
const int inf = 0x3f3f3f3f;
int n;
int x[maxn], y[maxn];
int d[maxn];
int dis[maxn][maxn];
int vis[maxn];

int Dijstra(int s) {
	memset(vis, 0, sizeof vis);
	for (int i = 1; i <= n; i++) {
		d[i] = dis[s][i];
	}

	for (int i = 0; i < n; i++) {
		int x, m = inf;
		for (int y = 1; y <= n; y++) {
			if (!vis[y] && d[y] < m) {
				x = y;
				m = d[y];
			}
		}
		vis[x] = 1;
		for (int y = 1; y <= n; y++) {
			// 修改相应松弛条件
			d[y] = min(d[y], max(d[x], dis[x][y]));
		}
	}
	return d[2];
}

int main() {
	// freopen("E://input.txt", "r", stdin);
	int kase = 0;
	while (~scanf("%d", &n) && n) {
		kase++;
		for (int i = 1; i <= n; i++) {
			scanf("%d %d", &x[i], &y[i]);
		}
		for (int i = 1; i <= n; i++) {
			for (int j = 1; j <= n; j++) {
				dis[i][j] = dis[j][i] = (x[i] - x[j])*(x[i] - x[j]) + (y[i] - y[j])*(y[i] - y[j]);
			}
		}
		int l = Dijstra(1);
		printf("Scenario #%d\nFrog Distance = %.3f\n", kase, sqrt((double)l));
		puts("");
	}
	return 0;
}
```

