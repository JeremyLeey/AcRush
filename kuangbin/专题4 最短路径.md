[toc]

# 单源最短路径Dijstra算法

Dijstra的思想是贪心，每次挑选d值最小的点用于松弛，**因为不存在负权边，所以d值最小的点此时的最短距离已经确定**。比如，此时挑出的最小d值是i，如果有一条路径，经过j最终到达i的最短路更短，那么则有

```C++
d[j] + 新的路径边 > d[i]，但是有d[j] > d[i], 所以新的路径边 < 0, 和无负权边矛盾，因此不成立；
```

```C++
/**
清除所有点标号
d[s] = 0, 其余d[i] = INF;
循环n次{
  在所有未标记的点中,挑选一个d值最小的点x
  给结点x标记
  对于从x出发的所有边,更新d[y] = min(d[y], d[x] + w(x, y));
}
**/

void Dijstra(int s) {
	memset(vis, 0, sizeof vis);
	for (int i = 0; i < n; i++) d[i] = inf;
	d[s] = 0;
	for (int i = 0; i < n; i++) {
		int x, m = inf;
		for (int j = 0; j < n; j++) {
			if (!v[j] && d[j] < m) {
				m = d[j];
				x = j;
			}
		}
		vis[x] = 1;
		for (int j = 0; j < n; j++) {
			d[j] = min(d[j], d[x] + w[x][j]);
		}
	}
}
```

复杂度O(n2),利用优先队列优化可以将复杂度优化到O(mlogn),其中m是边数。极限情况m和n2是同阶的，但大多数情况下图都是稀疏的，m远小于n2。对于稀疏图也常采用邻接链表来存储图。虽然在最短路问题中，每条边只有边权这一个属性，但后面的最大流以及最小费用流中还会出现容量，流量以及费用等属性。所以在这里使用一个称为Edge的结构体，这会让这里的代码与后面的代码在风格上更统一。代码如下：

```C++
struct Edge{
	int from, to, dist;
	Edge(int u, int v, int d): from(u),to(v),dist(d) {}
};

struct Node{
	int d, u;
	bool operaotr < (const Node& rhs) const {
		return d > rhs.d;
	}
};

struct Dijstra {
	int n, m;
	vector<Edge> G[maxn]; //  邻接链表
	bool vis[maxn];
	int d[maxn];
	int p[maxn];
	
	void init(int n) {
		this->n = n;
		for (int i = 0; i < n; i++) G[i].clear();
	}
	
	void addEdge(int u, int v, int dist) {
		// 无向图两边都要push 有向图只有一边
		G[u].push_back(Edge(u, v, dist));
		G[v].push_back(Edge(v, u, dist));
	}
	
  void Dijstra(int s) {
		priority_queue<Node> Q;
		for (int i = 0; i < n; i++) d[i] = INF;
		d[s] = 0;
		memset(vis, 0, sizeof vis);
		Q.push((Node){0, s});
		while (!Q.empty()) {
			Node curr = Q.top(); Q.pop();
			int u = curr.u;
			if (vis[u]) continue; // 可以省去vis的开销，此处判断改成 if (d[u] < cuur.d) continue;
			vis[u] = true;
			for (int i = 0; i < G[u].size(); i++) {
				Edge e = G[u][i];
				if (d[e.to] > d[u] + e.dist) {
					d[e.to] = d[u] + e.dist;
					Q.push((Node){d[e.to], e.to});
				}
			}
		}
	}
};
```

在松弛成功后，需要修改节点e.to的优先级，但STL中的优先队列不提供修改优先级的操作。因此，只能将新元素重新插入优先队列，这样做并不会影响结果的正确性，因为d值小的节点自然会先出队列。为了防止节点的重复扩展，如果发现新取出来的节点曾经已经被访问过vis[u]，应该直接把它扔掉(或者采用注释的方法进行判断)。

# 带负权边的Bellman-Ford算法

当负权存在时，连最短路都不一定存在了。尽管如此，还是有办法在最短路存在的情况下把它求出来。首先，如果最短路存在，则一定存在一个不含环的最短路。这是因为如果该环为正环或零环，则去掉该环能得到更短的路径；如果为负环，则最短路不存在，因为可以绕着负环走无限多次。

类似于Dijstra算法的松弛操作，我们把对图中的每一条边都执行一次```d[v]=min(d[v],d[u]+w(u,v)) ```的判断成为一轮松弛迭代。可以证明，**若图中存在最短距离未确认的顶点，则每一次迭代后至少增加一个已确认顶点**。证明过程如下

```c++
1. 初始情况下，只有起点s的最短距离已经确定;
2. 假设在第一轮迭代后，没有一个顶点的最短距离被确定，即与s相邻的顶点仍处于未确定状态，假设vi是s相邻的顶点之一；
  2.1 那么存在一条由s出发经过另一个相邻顶点vj最终到达vi的路径<s,vj,..,vi>，其距离小于路径<s, vi>;
	2.2 若 j==i,则说明路径<vi,...,vi>为负权回路，与条件矛盾，不成立；
      若 j!=i,同理存在另一条由s出发经过相邻顶点vk最终到达vj的路径<s,vk,...,vj>,其距离小于路径<s, vj>;
			同样更新d[i]为<s,vk,...,vj,...,vi>,该距离小于<s, vi>
  2.3 因为s的相邻顶点个数是有限个，如此往下寻找，则在某一时刻,一定存在一条路径<s,vi,...,vk,...,vj,...,vi>,其距离小于路径<s, vi>,则存在负环，与条件矛盾；
3. 对于任意次迭代后，被确定距离的顶点为集合S，则同理可以证明下一次迭代后，集合S的元素至少增加一个。
```

证明参考：[数据结构（十一）：最短路径(Bellman-Ford算法)](https://www.jianshu.com/p/b876fe9b2338)

因为不含环,最短路最多只经过不算起点的n-1个结点，可以通过n-1轮松弛操作得到。代码如下，假设起点为0

```C++
for (int i = 0; i < n; i++) d[i] = INF;
d[0] = 0;
for (int k = 0; k < n-1; k++) {
	// 迭代n-1次
	for (int i = 0; i < m; i++) {
		// 检查每条边
		int x = u[i], y = v[i];
		if (d[x] < INF) {
			d[y] = min(d[y], d[x]+w[i]); // 松弛
		}
	}
}
```

Bellman-Ford算法同样可以检测负环，即n-1轮迭代之后，如果仍有```d[v] < d[u] + w(u, v)```,那么存在负权回路。可以看到Bellmaxn-Ford算法的时间复杂度为O(VE),其中V为顶点数目，E为边数，对于稠密图来说该算法复杂度较大。因此常用SPFA(Shorest Path Faster Algorithm)来代替Bellman-Ford算法。

# Bellman-Ford优化后的SPFA算法(检测负环)

可以看到BF算法的缺点在于即使某一次迭代更新后已经获得了所有的最短路径，它还是会继续执行接下来的迭代过程。不难发现，起点s到某一个顶点的最短路径的第一条边，必定是s与其邻接点连成的边。所以当我们在第一次松弛后，松弛的边必定包含上述的第一条边。对于最短路径的第二条边我们同理。因此SPFA算法用FIFO队列来代替上面的循环检查，算法思路如下：

```C++
1. 设置一个队列，初始时将s加入队列中。
2. 若队列不为空，弹出队首元素curr，松弛和其邻接点组成的边，并将松弛成功的邻接点入队，若其未在队列中；
3. 重复以上步骤；
```

代码如下

```C++
bool spfa(int s) {
	queue<int> Q;
	memset(inq, 0, sizeof inq); // inq[i]-点i是否在队列中
	memset(cnt, 0, sizeof cnt); // cnt[i]-点i的入队次数
	for (int i = 0; i < n; i++) d[i] = INF;
	d[s] = 0;
	inq[s] = true;
	Q.push(s);
	while (!Q.empty()) {
		int u = Q.front(); Q.pop();
		inq[u] = false;
		for (int i = 0; i < G[u].size(); i++) {
			Edge &e = edges[G[u][i]];
			if (d[u] < INF && d[e.to] > d[u] + e.dist) {
				d[e.to] = d[u] + e.dist;
				p[e.to] = G[u][i];
				if (!inq[e.to]) {
					Q.push(e.to);
					inq[e.to] = true;
					if (++cnt[e.to] > n) {
						return false; // 存在负环
					}
				}
			}
		}
	}
	return true;
}
```

spfa算法同样可以用于判断负环。当存在负环时，则上述循环陷入死循环。我们用一个cnt数组表示节点的入队次数，若一个节点入队次数超过n次，则说明存在负环。可以这么理解，spfa本质上是bfs，入队的时候表明该点被松弛更新，即每次入队则该最短路径边数至少加一，由于不存在负环所以最短路径最多n-1条边，为什么不是>n-1呢？这是因为对于一个点的图来说，n-1的话就会导致被判断为负环，综合考虑为>n。

# 多源最短路径Floyd-Warshall算法

```c++
思想是动态规划：从i到j只经过前k个结点的最短路径为加入第k个节点后是否存在一条从i到k再到j更短的路
d[i][j][k] = max(d[i][j][k-1], d[i][k][k-1] + d[k][j][k-1]);
利用滚动数组优化如下：
for (int k = 0; k < n; k++)
	for (int i = 0; i < n; i++)
		for (int j = 0; j < n; j++) 
			d[i][j] = max(d[i][j], d[i][k] + d[k][i]);
初始化d[i][i]=dis(i,j),若两点间没边则为inf。
```

# 有向图的传递闭包

在有向图中，有时不必关心路径的长度，而只关心两点间是否有通路，则可以用1和0表示连通和不连通。主算法中相应改成

```C++
d[i][j] = d[i][j] || (d[i][k] && d[k][j])
初始化的话若两点间有边则为1，否则为0。
```

# 20.2.24 POJ -2387 Til the Cows Come Home 最短路裸题

```C++
#include <cstdio>
#include <queue>
#include <cstring>
#include <algorithm>

using namespace std;

const int maxn = 1005;
const int inf = 0x3f3f3f3f;

int t, n, m[maxn][maxn];
int d[maxn], vis[maxn];

void Dijstra(int s) {
	for (int i = 1; i <= n; i++) {
		d[i] = inf;
		vis[i] = 0;
	}
	d[s] = 0;
	for (int i = 0; i < n; i++) {
		int p = -1, minp = inf;
		for (int j = 1; j <= n; j++) {
			if (!vis[j] && d[j] < minp) {
				minp = d[j];
				p = j;
			}
		}
		if (p == -1) return;
		vis[p] = 1;
		for (int j = 1; j <= n; j++) {
			d[j] = min(d[j], d[p] + m[p][j]);
		}
	}
}

int main() {
	while (~scanf("%d %d", &t, &n)) {
		for (int i = 1; i <= n; i++) {
			for (int j = 1; j <= n; j++) {
				m[i][j] = inf;
			}
		}
		for (int i = 0; i < t; i++) {
			int u, v, d;
			scanf("%d %d %d", &u, &v, &d);
			// 题目可能会给重复边
			m[u][v] = m[v][u] = min(m[u][v], d);
		}
		Dijstra(n);
		printf("%d\n", d[1]);
	}
}

```

换用邻接链表以及使用优先队列优化

```C++
#include <cstdio>
#include <queue>
#include <cstring>
#include <algorithm>

using namespace std;

const int maxn = 1005;
const int inf = 0x3f3f3f3f;

int t, n;
int d[maxn], vis[maxn];

struct Edge {
	int from, to, dist;
	Edge(int u, int v, int d) : from(u), to(v), dist(d) {}
};

struct Node {
	int d, u;
	bool operator < (const Node& rhs) const {
		return d > rhs.d;
	}
	Node(int d_, int u_) :d(d_), u(u_) {}
};

vector<Edge> G[maxn];

void Dijstra(int s) {
	priority_queue<Node> q;
	for (int i = 1; i <= n; i++) d[i] = inf;
	d[s] = 0;
	memset(vis, 0, sizeof vis);
	q.push(Node(0, s));
	while (!q.empty()) {
		Node curr = q.top(); q.pop();
		int u = curr.u;
		if (vis[u]) continue;
		vis[u] = true;
		for (int i = 0; i < G[u].size(); i++) {
			Edge v = G[u][i];
			if (d[v.to] > d[u] + v.dist) {
				d[v.to] = d[u] + v.dist;
				q.push(Node(d[v.to], v.to));
			}
		}
	}
}

int main() {
	while (~scanf("%d %d", &t, &n)) {
		for (int i = 1; i <= n; i++) G[i].clear();
		for (int i = 0; i < t; i++) {
			int u, v, d;
			scanf("%d %d %d", &u, &v, &d);
			G[u].push_back(Edge(u, v, d));
			G[v].push_back(Edge(v, u, d));
		}
		Dijstra(n);
		printf("%d\n", d[1]);
	}
}
```

# 20.2.24 POJ-2253 Frogger 最大值最小化二分的Floyd传递闭包 or 变形的Dijstra

给你n个点的坐标同时告诉你起点s与终点t,从s到t有很多种路可以走，一条路有很多边组成，记d是一种路中的最大边，求d的最小值。

**方法一**

最大值最小化问题常用二分解决，本题也可以。对边的长度进行二分，对于当前中值m来说，判断从起点s到终点t的可连通性，采用floyd传递闭包即可解决。注意这里的边长最好全部用int处理，直到之后输出时才求其根号。本题我用double变量进行二分，精度选的很小时直接TLE，选得稍微大一点才勉强A过。

```c++
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>

using namespace std;

const int maxn = 205;
const int inf = 0x3f3f3f3f;
int n;
int x[maxn], y[maxn];
int d[maxn][maxn], dis[maxn][maxn];

bool floyd(int m) {

	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= n; j++) {
			d[i][j] = dis[i][j] > m ? 0 : 1;
		}
	}

	for (int k = 1; k <= n; k++) {
		for (int i = 1; i <= n; i++) {
			for (int j = 1; j <= n; j++) {
				d[i][j] = d[i][j] || (d[i][k] && d[k][j]);
				if (d[1][2]) return true;
			}
		}
	}

	return false;
}
int main() {
	// freopen("E://input.txt", "r", stdin);
	int kase = 0;
	while (~scanf("%d", &n) && n) {
		kase++;
		for (int i = 1; i <= n; i++) {
			scanf("%d %d", &x[i], &y[i]);
		}
		for (int i = 1; i <= n; i++) {
			for (int j = 1; j <= n; j++) {
				dis[i][j] = dis[j][i] = (x[i] - x[j])*(x[i] - x[j]) + (y[i] - y[j])*(y[i] - y[j]);
			}
		}

		int l = 0, r = 2000005, m = 0;
		while (r > l) {
			m = (l + r) / 2;
			// 在m距离下判断1和2号点是否连通
			if (floyd(m)) {
				r = m;
			}
			else {
				l = m+1;
			}
		}
		printf("Scenario #%d\n", kase);
		printf("Frog Distance = %.3f\n", sqrt((double)l));
		puts("");
	}
	return 0;
}
```

**方法二**

由于起点终点均已告诉，所以可以直接用Dijstra解决。Dijstra中d[i]的含义则变成从起点s到终点i时不同路径的边的最大值的最小值，起初d[i] = Distance(s, i)。在松弛阶段修改相应条件即可。

```C++
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>

using namespace std;

const int maxn = 205;
const int inf = 0x3f3f3f3f;
int n;
int x[maxn], y[maxn];
int d[maxn];
int dis[maxn][maxn];
int vis[maxn];

int Dijstra(int s) {
	memset(vis, 0, sizeof vis);
	for (int i = 1; i <= n; i++) {
		d[i] = dis[s][i];
	}

	for (int i = 0; i < n; i++) {
		int x, m = inf;
		for (int y = 1; y <= n; y++) {
			if (!vis[y] && d[y] < m) {
				x = y;
				m = d[y];
			}
		}
		vis[x] = 1;
		for (int y = 1; y <= n; y++) {
			// 修改相应松弛条件
			d[y] = min(d[y], max(d[x], dis[x][y]));
		}
	}
	return d[2];
}

int main() {
	// freopen("E://input.txt", "r", stdin);
	int kase = 0;
	while (~scanf("%d", &n) && n) {
		kase++;
		for (int i = 1; i <= n; i++) {
			scanf("%d %d", &x[i], &y[i]);
		}
		for (int i = 1; i <= n; i++) {
			for (int j = 1; j <= n; j++) {
				dis[i][j] = dis[j][i] = (x[i] - x[j])*(x[i] - x[j]) + (y[i] - y[j])*(y[i] - y[j]);
			}
		}
		int l = Dijstra(1);
		printf("Scenario #%d\nFrog Distance = %.3f\n", kase, sqrt((double)l));
		puts("");
	}
	return 0;
}
```

# 20.2.24 POJ 1797 Heavy Transporation 变形Dijstra 

给你n个点，以及m条边，现在问你从点1到点n的不同路线中权重的最小值的最大值。

---

Dijstra的关键在于“松弛”一步，选择一个点进行松弛。我们令d[i]代表从起点到节点i最小权重的最大值，那么松弛一步就可以改为

```
d[v] = max(d[v], min(d[u], w[u][v]))
```

因此队列每次要出来d值最大的那一个，这样才能保证松弛的正确性。最后就是这题每个样例输出结束后都要打一个空行。

````C++
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <queue>

using namespace std;

const int maxn = 1005;
const int inf = 0x3f3f3f3f;
int n, m;

struct Edge{
    int from, to, dist;
    Edge(int u, int v, int d): from(u), to(v), dist(d) {}
};

vector<Edge> G[maxn];
int d[maxn], vis[maxn];

struct Node{
    int u, d;
    bool operator < (const Node &rhs) const {
        return d < rhs.d;
    }
};

int Dijstra(int s) {
    for (int i = 1; i <= n; i++) d[i] = 0;
    d[s] = inf;
    memset(vis, 0, sizeof vis);

    priority_queue<Node> Q;
    Q.push((Node){s, 0});
    while (!Q.empty()) {
        Node curr = Q.top(); Q.pop();
        int u = curr.u;
        if (vis[u]) continue;
        vis[u] = true;
        for (int i = 0; i < G[u].size(); i++) {
            Edge e = G[u][i];
            if (d[e.to] < min(d[u], e.dist) ) {
                d[e.to] = min(d[u], e.dist);
                Q.push((Node){e.to, d[e.to]});
            }
        }
    }
    return d[n];
}

int main() {
    int t, kase = 0;
    scanf("%d", &t);
    while (t--) {
        kase++;
        scanf("%d %d", &n, &m);
        for (int i = 1; i <= n; i++) G[i].clear();

        for (int i = 0; i < m; i++) {
            int u, v, d;
            scanf("%d %d %d", &u, &v, &d);
            G[u].push_back(Edge(u, v, d));
            G[v].push_back(Edge(v, u, d));
        }

        int res = Dijstra(1);
        printf("Scenario #%d:\n", kase);
        printf("%d\n\n", res);
    }
    return 0;
}
````

# 20.2.25 POJ 3268 Sliver Pow Party 单源来回最短路径

n个节点的有向图，其中一个给定终点x，然后从其余节点出发到达x然后再从x返回到起点，每趟都要求是最短路，求来回一趟最远的那个。

---

首先这是一个多源但是终点给定的最短路问题，floyd的复杂度为1000^3因此超时。所以采用Dijstra，一种方式是循环n次的Dijstra，另一种正向反向一遍Dijstra即可。有向图的多源最短路把有向、起点、终点颠倒一下就变成单源最短路。颠倒可以采用另一个G存储或者转置一下矩阵。

---

这里我因为push那个地方写成了e.dist而不是d[e.to]一直WA了一个多小时。。。太蠢了！

```C++
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <queue>

using namespace std;

const int maxn = 1005;
const int inf = 0x3f3f3f3f;

int n, m, x;
int d[maxn][2];

struct Edge{
    int from, to, dist, flag;
    Edge(int u, int v, int d, int f): from(u), to(v), dist(d), flag(f) {}
};

struct Node{
    int u, d;
    bool operator < (const Node& rhs) const {
        return d > rhs.d;
    }
};
vector<Edge> G[maxn];

// 从起点s 只走正向边的最短路
void Dijstra(int s, int flag) {
    priority_queue<Node> q;
    q.push((Node){s, 0});
    d[s][0] = d[s][1] = 0;
    while (!q.empty()) {
        Node curr = q.top(); q.pop();
        int u = curr.u;
        if (d[u][flag] < curr.d) continue;
        for (int i = 0; i < G[u].size(); i++) {
            Edge e = G[u][i]; // 区分这条边是正向边还是反向边
            if (e.flag != flag) continue;
            if (d[e.to][flag] > d[u][flag] + e.dist) {
                d[e.to][flag] = d[u][flag] + e.dist;
                q.push((Node){e.to, d[e.to][flag]});
            }
        }

    }
}

int main() {
    while (~scanf("%d %d %d", &n, &m, &x)) {
        for (int i = 1; i <= n; i++) {
            G[i].clear();
            d[i][0] = d[i][1] = inf;
        }

        for (int i = 0; i < m; i++) {
            int u, v, c;
            scanf("%d %d %d", &u, &v, &c);
            G[u].push_back(Edge(u, v, c, 0)); // 正向边
            G[v].push_back(Edge(v, u, c, 1)); // 反向边
        }
        // 多源最短路径问题
        for (int i = 0; i < 2; i++) Dijstra(x, i);
        int ans = 0;
        for (int i = 1; i <= n; i++) {
            if (i != x && d[i][0] < inf && d[i][1] < inf)
                ans = max(ans, d[i][0] + d[i][1]);
        }

        printf("%d\n", ans);

    }
    return 0;
}
```

# 20.2.28 POJ-1860 Currency Exchange SPFA检测负环

给你n种货币，然后告诉你m种交换关系，每次交换按照收取一定的手续费，现在你拥有S货币V个，能否在一些交换之后，成功换回S货币且价值增加。

---

建图。n种货币n个节点，货币之间的转换关系为边。令d[i]表示到达第i个节点时能获得的最大价值，起初d[S]=V,其余d[i]=0。那么则有```d[v] < d[u] + w(u, v)```时进行松弛操作。如何判断能赚？只需判断当u==s时最大价值是否大于初始价值即可。其实也是一个判断该图是否有正环的问题，因为有正环的话就能一直换一直换，总有能赚的时候。

```C++
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <queue>
#include <vector>
using namespace std;

const int maxn = 105;
const int inf = 0x3f3f3f3f;
int N, M, S;
double V;

struct Edge{
    int from, to;
    double rate, comm;
    Edge(int f, int t, double r, double c): from(f), to(t), rate(r), comm(c) {}
};
vector<Edge> G[maxn];
double d[maxn];
bool inq[maxn];

bool spfa() {
    queue<int> q;
    memset(inq, 0, sizeof q); // 是否在队列中
    for (int i = 1; i <= N; i++) d[i] = 0; // 到达该点所能获得的最大钱数
    d[S] = V;
    inq[S] = true;
    q.push(S);
    while (!q.empty()) {
        int u = q.front(); q.pop();
        inq[u] = false;
        if (u == S && d[u] > V) return true;
        for (int i = 0; i < G[u].size(); i++) {
            Edge e = G[u][i];
            double t = (d[u] - e.comm) * e.rate; // 这一次到达e.to所能获得的最大钱数
            if (d[e.to] < t) {
                // 这次交换比上次要赚
                d[e.to] = t;
                if (!inq[e.to]) {
                    q.push(e.to);
                    inq[e.to] = true;
                }
            }
        }
    }
    return false;

}

int main() {
    while (~scanf("%d %d %d %lf", &N, &M, &S, &V)) {
        for (int i = 0; i <= N; i++) G[i].clear();
        int a, b;
        double rateAB, rateBA, comAB, comBA;
        for (int i = 0; i < M; i++) {
            scanf("%d %d %lf %lf %lf %lf", &a, &b, &rateAB, &comAB, &rateBA, &comBA);
            G[a].push_back(Edge(a, b, rateAB, comAB));
            G[b].push_back(Edge(b, a, rateBA, comBA));
        }
        puts(spfa() ? "YES" : "NO");
    }
    return 0;
}
```

这道题建图一直绕歪了，把交换点当成图的节点了，还需要勤加练习。业精于勤荒于嬉。

# 20.2.28 POJ-3259 Wormholes spfa判断负环

带负权的有向图，判断是否存在负环。采用spfa做法的话我随意选择了一个起点，不知道会不会出现图不是连通图的情况。

```C++
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <queue>
#include <vector>

using namespace std;

const int maxn = 505;
const int inf = 0x3f3f3f3f;
int N, M, W;

struct Edge{
    int from, to, dist;
    Edge(int f, int t, int d):from(f), to(t), dist(d) {}
};
vector<Edge> G[maxn];
int inq[maxn], cnt[maxn], d[maxn];

bool spfa(int s) {
    queue<int> q;
    memset(inq, 0, sizeof inq);
    memset(cnt, 0, sizeof cnt);
    for (int i = 1; i <= N; i++) d[i] = inf;
    d[s] = 0;
    q.push(s);
    inq[s] = true;
    while (!q.empty()) {
        int u = q.front(); q.pop();
        inq[u] = false;
        for (int i = 0; i < G[u].size(); i++) {
            Edge e = G[u][i];
            if (d[e.to] > d[u] + e.dist) {
                d[e.to] = d[u] + e.dist;
                if (!inq[e.to]) {
                    q.push(e.to);
                    inq[e.to] = true;
                    if (++cnt[e.to] > N) {
                        return true;
                    }
                }
            }
        }
    }
    return false;
}
int main() {
    int F;
    scanf("%d", &F);
    while (F--) {
        int S, E, T;
        scanf("%d %d %d", &N, &M, &W);
        for (int i = 1; i <= N; i++) G[i].clear();
        for (int i = 1; i <= M; i++) {
            scanf("%d %d %d", &S, &E, &T);
            // bidirectional
            G[S].push_back(Edge(S, E, T));
            G[E].push_back(Edge(E, S, T));
        }

        for (int i = 1; i <= W; i++) {
            scanf("%d %d %d", &S, &E, &T);
            // one way path
            G[S].push_back(Edge(S, E, -T));
        }
        // 起点任意选择即可 该点被孤立？
        puts(spfa(1) ? "YES" : "NO");
    }
    return 0;
}
```

# 20.2.28 POJ-2240 Arbitrage spfa or floyd判断负环

还是给定一些货币的交换关系，问你能够通过交换实现盈利。和POJ-1860很相似的题目，直接可以用spfa水过，但是我发现两年前我就水过这道题，当时是使用floyd计算的，其实floyd也可以用于判断负环，只需要判断自己到自己的最短路径是否小于0不就ok了吗！

```C++
#include <cstdio>
#include <string>
#include <map>
#include <cmath>
#include <algorithm>

using namespace std;
const int e = 1e-8;
map<string, int> hashm;
int n, m;
char c1[100], c2[100];
double ratio, road[35][35], dp[35][35];

void floyd_warshall() {
	for (int k = 0; k < n; k++) {
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < n; j++) {
				dp[i][j] = max(dp[i][j], dp[i][k]*dp[k][j]);
			}
		}
	}
}

int main() {
	//freopen("H://input.txt", "r", stdin);
	int cases = 0;
	while (~scanf("%d", &n)) {
		if (n == 0) break;
		hashm.clear();
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < n; j++) {
				if (i == j) dp[i][j] = 1.0;
				else dp[i][j] = 0.0;
			}
		}
		cases++;
		
		for (int i = 0; i < n; i++) {
			scanf("%s", c1);
			hashm[c1] = i;
		}
		scanf("%d", &m);
		for (int i = 0; i < m; i++) {
			scanf("%s %lf %s", c1, &ratio, c2);
			int u = hashm[c1],  v = hashm[c2];
			dp[u][v] = ratio;
		}
		
		floyd_warshall();
		bool tag = false;
		for (int i = 0; i < n; i++) {
			if (dp[i][i] - 1.0 > e) {
				tag = true;
				break;
			}
		} 
		printf("Case %d: %s\n", cases, tag ? "Yes" : "No");
	}
	return 0;
}

```

# 20.2.29 POJ-1502 MPI Maelstrom Dijstra裸题

给定n个信号站，以及邻接矩阵，从1号站开始发射信号，问所有基站都收到信号的最短时间。信号的传输是这样的，一开始1号基站发射信号，第二台基站收到信号后，下一时刻两台基站可以同时往外再次发送信号。

---

根据题意稍加思考就可以得知答案应该是起点到全部基站的最短路其中最大的那一个，然后套一边Dijstra的模版了。

```C++
#include <cstdio>
#include <cstring>
#include <queue>
#include <algorithm>
#include <vector>
#include <cstdlib>

using namespace std;

const int maxn = 105;
const int inf = 0x3f3f3f3f;

int n, d[maxn];
struct Edge{
    int from, to, dist;
    Edge(int f, int t, int d): from(f), to(t), dist(d) {}
};

struct Node{
    int u, d;
    bool operator < (const Node& rhs) const {
        return d > rhs.d;
    }
};

vector<Edge> G[maxn];

void Dijstra(int s) {
    priority_queue<Node> q;
    for (int i = 0; i < n; i++) d[i] = inf;
    d[s] = 0;
    q.push(Node{s, 0});
    while (!q.empty()) {
        Node curr = q.top(); q.pop();
        int u = curr.u;
        if (d[u] < curr.d) continue;
        for (int i = 0; i < G[u].size(); i++) {
            Edge e = G[u][i];
            if (d[e.to] > d[u] + e.dist) {
                d[e.to] = d[u] + e.dist;
                q.push((Node){e.to, d[e.to]});
            }
        }
    }
}

int main() {

    char str[30];
    scanf("%d", &n);
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < i; j++) {
            scanf("%s", str);
            if (strcmp(str, "x") != 0) {
                // atoi
                int cost = atoi(str);
                G[i].push_back(Edge(i, j, cost));
                G[j].push_back(Edge(j, i, cost));
            }

        }
    }

    Dijstra(0);
    int ans = 0;
    for (int i = 1; i < n; i++)
        ans = max(ans, d[i]);
    printf("%d\n", ans);
    return 0;
}
```

# 20.3.1 POJ-3660 Cow Contest floyd传递闭包

n个人按照能力值进行比赛，现在告诉你一些能力值的胜负关系，问通过现有的比赛关系有几个人已经确定了排名。

---

胜负关系即有向边，对于第i个人，找出有a个人比i高，有b个人比i低，如果a+b==N-1那么这个人的排名就可以确定。因此可以求一次图的传递闭包，i到j可达即代表j比i低，i比j高，同时存储这个信息即可。我看网上说也可以用dfs来做，即正向图反向图分别计算一下出入度即可。

```c++
#include <cstdio>
#include <cstring>
#include <algorithm>

using namespace std;
const int maxn = 105;

int n, m, d[maxn][maxn];
int l[maxn], r[maxn];

void floyd() {
    for (int k = 1; k <= n; k++) {
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                d[i][j] |= d[i][k] & d[k][j];
            }
        }
    }
}
int main() {
    scanf("%d %d", &n, &m);
    memset(d, 0, sizeof d);
    memset(l, 0, sizeof l);
    memset(r, 0, sizeof r);

    for (int i = 0; i < m; i++) {
        int u, v;
        scanf("%d %d", &u, &v);
        d[u][v] = 1;
    }

    for (int i = 1; i <= n; i++) d[i][i] = 1;
    floyd();

    //
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            if (i != j && d[i][j]) {
                l[i]++;
                r[j]++;
            }
        }
    }
    int ans = 0;
    for (int i = 1; i <= n; i++) {
        if (l[i] + r[i] + 1 == n) {
            ans++;
        }
    }

    printf("%d\n", ans);
    return 0;
}
```

# 20.3.1 POJ-1511 Inviation Cards 单源来回最短路+链式前向星存图

给定有向图G，求一个从起点出发到各个点然后再回来的最短路和。类似于之前做的POJ-3268，但是这题的数据量好像有点大，使用vector存储邻接链表直接TLE，百度了一下使用链式前向星村图才通过。

## 链式前向星存图

我们知道图的存储方式有这么几种。

第一种是邻接矩阵，即二维矩阵存图，这种方式的优点是两点之间的近邻关系O(1)获取，缺点也很明显，稀疏图的空间开销太大。

第二种是使用STL_vector的邻接矩阵存图，解决了第一种方式在稀疏图情况下的空间开销大。但是也有缺点，就是vector实现虽然方便，但是空间时间开销都要比一般数组要大，因为vector扩容是开一个双倍空间然后copy过去。例如本题使用vector存储就会TLE。

第三种就是今天了解到的链式前向星存图，简单说来就是仅存储边，然后另开一个head数组来指明以顶点u开始的全部有向边。代码

```C++
struct Edge{
  int to, dist, next;
}edge[maxm];

int cnt = 0; //cnt代表的是第几条边，初始化为0
int head[maxn]; //head[i]代表以i为顶点的第一条边的位置，可以初始化为-1
void addEdge(int u, int v, int dist) {
  Edge[cnt].to = v;
  Edge[cnt].dist = dist;
  Edge[cnt].next = head[u];
  head[u] = cnt++;
}
// 遍历以u为顶点的全部边
for (int i = head[u]; i >= 0; i = edge[i].next)
```

需要注意的是，这种方式存储的话遍历的顺序和输入时遍历的边的顺序刚好相反，但这不影响在spfa，dfs，bfs等算法使用的正确性。一句话总结：以后如果知道确定边数，那么能使用方法3的情况下就尽量使用方式3从而避免vector爆时。

参考：[深度理解链式前向星](https://blog.csdn.net/acdreamers/article/details/16902023)

---

```C++
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>
#include <queue>

using namespace std;
typedef long long ll;
const int maxn = 1000005;
const ll inf = 1e15+10;

int T, N, M;

struct Edge{
    int from, to, next;
    ll dist;
}edge[2*maxn];

ll d[2][maxn];
int cnt, head[2][maxn];

struct Node{
    int u;
    ll d;
    bool operator < (const Node& rhs) const {
        return d > rhs.d;
    }
};

void addEdge(int u, int v, ll dist, int flag) {
    edge[cnt].from = u;
    edge[cnt].to = v;
    edge[cnt].dist = dist;
    edge[cnt].next = head[flag][u];
    head[flag][u] = cnt++;

}

void Dijstra(int s, int flag) {
    priority_queue<Node> q;
    for (int i = 1; i <= N; i++) d[flag][i] = inf;
    d[flag][s] = 0;
    q.push(Node{s, 0});
    while (!q.empty()) {
        Node curr = q.top(); q.pop();
        int u = curr.u;
        if (d[flag][u] < curr.d) continue;
        for (int i = head[flag][u]; i >= 0; i = edge[i].next) {
            Edge e = edge[i];
            if (d[flag][e.to] > d[flag][u] + e.dist) {
                d[flag][e.to] = d[flag][u] + e.dist;
                q.push(Node{e.to, d[flag][e.to]});
            }
        }
    }
}

int main() {
    scanf("%d", &T);
    while (T--) {
        scanf("%d %d", &N, &M);
        memset(head, -1, sizeof head);
        cnt = 0;

        for (int i = 0; i < M; i++) {
            int u, v;
            ll cost;
            scanf("%d %d %lld", &u, &v, &cost);
            addEdge(u, v, cost, 0);
            addEdge(v, u, cost, 1);
        }


        Dijstra(1, 0);
        Dijstra(1, 1);

        ll ans = 0;
        for (int i = 1; i <= N; i++) {
            ans += d[0][i] + d[1][i];
        }

        printf("%lld\n", ans);
    }
    return 0;
}
```

# 20.3.2 POJ 3159 Candies 差分约束初见 

差分约束的模版题。第一次接触差分约束，其实是根据最短路中的松弛条件d[v] > d[u] + e.dist来进行的，当d[v] > d[u] + e.dist进行松弛，其实就是满足d[v] <= d[u] + e.dist，把不等关系转化为这个然后建立有向边即可。最后求的是最大值，也就是最短路的值。

## 一篇非常好的最短路差分约束博客

[夜深人静写算法（四）- 最短路和差分约束](https://blog.csdn.net/whereisherofrom/article/details/78922648)

[差分约束](https://xiaoxiaoh.blog.csdn.net/article/details/104175793)

```C++
#include <cstdio>
#include <cstring>
#include <queue>
#include <algorithm>

using namespace std;

const int maxN = 30005;
const int maxM = 150005;
const int inf = 0x3f3f3f3f;
int N, M;

struct Edge{
    int from, to, dist, next;
    Edge() {}
    Edge(int f, int t, int d, int n): from(f), to(t), dist(d), next(n) {}
}edge[maxM];
int edgeCnt, head[maxN];
void addEdge(int u, int v, int dist) {
    edge[edgeCnt] = Edge(u, v, dist, head[u]);
    head[u] = edgeCnt++;
}

int d[maxN];

struct Node{
    int u, d;
    bool operator < (const Node& rhs) const {
        return d > rhs.d;
    }
};

void Dijstra(int s) {
    priority_queue<Node> q;
    for (int i = 1; i <= N; i++) d[i] = inf;
    d[s] = 0;
    q.push(Node{s, 0});
    while (!q.empty()) {
        Node curr = q.top(); q.pop();
        int u = curr.u;
        if (d[u] < curr.d) continue;
        for (int i = head[u]; i >= 0; i = edge[i].next) {
            Edge e = edge[i];
            if (d[e.to] > d[u] + e.dist) {
                d[e.to] = d[u] + e.dist;
                q.push(Node{e.to, d[e.to]});
            }
        }
    }
}
int main() {
    edgeCnt = 0;
    memset(head, -1, sizeof head);
    scanf("%d %d", &N, &M);
    for (int i = 0; i < M; i++) {
        int u, v, c;
        scanf("%d %d %d", &u, &v, &c);
        // d[v] - d[u] <= c;
        addEdge(u, v, c);
    }
    Dijstra(1);
    printf("%d\n", d[N]);
    return 0;
}
```

# 20.3.2 POJ-2502 SubWay 最短路裸题

告诉你n条地铁线，以及家和学校的坐标，步行的话是10km/h,乘地铁是40km/h,问从家到学校的最短时间。

---

最短路模版题，这题就在建边时有一点点绕，本来想着全用int处理最后统一的但有点画蛇添足，直接计算出两个站点所需要的时间即可。由于是无向图因为边的数量一开始开小了RE了两次。

```C++
#include <cstdio>
#include <cstring>
#include <queue>
#include <algorithm>
#include <cmath>

using namespace std;
typedef long long ll;

const int maxN = 205;
const int maxM = maxN * maxN;
const int inf = 0x3f3f3f3f;

int pointCnt = 0;
struct Point{
    ll x, y;
}point[205];

int edgeCnt = 0, head[maxM];
struct Edge{
    int from, to, next;
    double dist;
    Edge() {}
    Edge(int f, int t, double d, int n): from(f), to(t), dist(d), next(n) {}
}edge[maxM];
void addEdge(int u, int v, double dist) {
    edge[edgeCnt] = Edge(u, v, dist, head[u]);
    head[u] = edgeCnt++;
}

struct Node{
    int u;
    double d;

    bool operator < (const Node &rhs) const {
        return d > rhs.d;
    }
};

double d[maxN];
bool islink[maxN][maxN]; // 防止重复建边用的，用来减小edge数组的大小
void Dijstra(int s) {
    priority_queue<Node> q;
    for (int i = 1; i < pointCnt; i++) d[i] = (double)inf;
    d[s] = 0;
    q.push(Node{s, 0});
    while (!q.empty()) {
        Node curr = q.top(); q.pop();
        int u = curr.u;
        if (d[u] < curr.d) continue;
        for (int i = head[u]; i >= 0; i = edge[i].next) {
            Edge e = edge[i];
            if (d[e.to] > d[u] + e.dist) {
                d[e.to] = d[u] + e.dist;
                q.push(Node{e.to, d[e.to]});
            }
        }
    }
}

double calDistance(ll x1, ll y1, ll x2, ll y2) {
    return sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2));
}

int main() {
    // freopen("/Users/leey/CLionProjects/cppLearn/input", "r", stdin);
    memset(head, -1, sizeof head);
    memset(islink, 0, sizeof islink);
    scanf("%lld %lld %lld %lld", &point[1].x, &point[1].y, &point[2].x, &point[2].y);
    pointCnt = 3;
    ll preX = -1, preY = -1, x, y;
    while (~scanf("%lld %lld", &x, &y)) {
        if (x == -1 && y == -1) {
            preX = preY = -1;
            continue;
        }
        point[pointCnt].x = x, point[pointCnt].y = y;
        if (preX != -1) {
            double dis = calDistance(x, y, preX, preY)*3/2000.0;
            addEdge(pointCnt-1, pointCnt, dis);
            addEdge(pointCnt, pointCnt-1, dis);
            islink[pointCnt-1][pointCnt] = islink[pointCnt][pointCnt-1] = 1;
        }
        preX = x, preY = y;
        pointCnt++;
    }
    // printf("Read Done with pointCnt = %d\n", pointCnt);
    for (int i = 1; i < pointCnt; i++) {
        for (int j = i+1; j < pointCnt; j++) {
            if (islink[i][j]) continue;
            double dis = calDistance(point[i].x, point[i].y, point[j].x, point[j].y) * 3 / 500; //步行时间
            addEdge(i, j, dis);
            addEdge(j, i, dis);
        }
    }

    Dijstra(1);
    printf("%d\n", (ll)(d[2] + 0.5));
    return 0;
}
```

# 20.3.4 POJ-1062 昂贵的婚礼 区间枚举+多次Dijstra(⭐️)

现在告诉你n个物品的价格、等级，同时告诉你一些代替关系，比如直接购买物品a需要1000金，但是先购买物品b，然后只需要在添加500金就可以交换到物品a。同时，过程后购买物品的等级之差不能超过一个给定的常数M。现在问换到1号物品的最小花费。

---

如果不考虑等级的限制，会发现这是一道Dijstra的裸题。一开始想的是在Dijstra的过程中同时考虑等级之差，但是这样一下就把Dijstra改的面目全非。后来看了网上的题解才知道，因为目标是换到1号物品，又由于给定常数M，所以就能枚举一些区间，只要购买的物品的等级都在这一个区间内，就符合题意。所以，枚举全部的区间，对于每一个区间求取一次Dijstra最短路并加上价值区间的限定即可。

```C++
#include <cstdio>
#include <cstring>
#include <queue>
#include <algorithm>
#include <cmath>
#include <climits>

using namespace std;
// 10:43, 11:33
const int maxN = 105;
const int maxM = maxN * maxN;
const int inf = 0x3f3f3f3f;

int M, N, P, L, X, T, V;
int level[maxN];

struct Edge{
    int from, to, dist, next;
    Edge() {}
    Edge(int f, int t, int d, int n): from(f), to(t), dist(d), next(n) {}
}edge[maxM];
int edgeCnt = 0, head[maxN];

void addEdge(int u, int v, int dist) {
    edge[edgeCnt] = Edge(u, v, dist, head[u]);
    head[u] = edgeCnt++;
}

struct Node{
    int u, d;
    bool operator < (const Node& rhs) const {
        return d > rhs.d;
    }
};
int d[maxN];

void Dijstra(int s, int left, int right) {
    priority_queue<Node> q;
    for (int i = 1; i <= N; i++) d[i] = inf;
    d[s] = 0;
    q.push(Node{s, 0});
    while (!q.empty()) {
        Node curr = q.top(); q.pop();
        int u = curr.u;
        if (d[u] < curr.d) continue;
        for (int i = head[u]; i >= 0; i = edge[i].next) {
            Edge e = edge[i];
            if (level[e.to] < left || level[e.to] > right) continue;
            if (d[e.to] > d[u] + e.dist) {
                d[e.to] = d[u] + e.dist;
                q.push(Node{e.to, d[e.to]});
            }
        }
    }
}

int main() {
    memset(head, -1, sizeof head);
    memset(level, 0, sizeof level);
    scanf("%d %d", &M, &N);
    for (int i = 1; i <= N; i++) {
        scanf("%d %d %d", &P, &L, &X);
        level[i] = L;
        addEdge(0, i, P);
        for (int j = 0; j < X; j++) {
            scanf("%d %d", &T, &V);
            // 替代品的编号 和优惠价格 有向边
            addEdge(T, i, V);
        }
    }
    // 以终点枚举区间+枚举可能的区间
    int ans = INT_MAX;
    for (int i = max(level[1]-M, 0); i <= level[1]; i++) {
        Dijstra(0, i, i+M);
        ans = min(ans, d[1]);
    }

    printf("%d\n", ans);
}
```

做题的时候不要在一棵树上吊死，当觉得这个实现有一些困难或者会改来改去，不如换一种思路去处理。还有就是不要对现有的算法进行大规模的修改，有可能就是你想错了。

# 20.3.7 POJ-1847 Tram 简单建图Dijstra

地图上有n个站点，每个点都由k条铁路经过。铁路连接两个站点，每个站点都由一个默认方向，当火车到达该站点时只能从默认的方向出去，如果想要从其他地方出去需要改变一次该站点的方向，现在告诉你一个起点和终点，问你从该起点到终点最少要改变多少次方向。

---

默认方向的两点权值为0，需要改变方向两点权值为1，建图，然后套最短路模版即可。由于每个点其实只会通过一次所以不用考虑转变方向后再次到达的问题。

```C++
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <queue>

using namespace std;

const int maxN = 105;
const int maxM = maxN * maxN;
const int inf = 0x3f3f3f3f;

int N, A, B, K, V;

struct Edge{
    int from, to, dist, next;
    Edge() {}
    Edge(int f, int t, int d, int n): from(f), to(t), dist(d), next(n) {}
}edge[maxM];

int edgeCnt = 0, head[maxM];
void addEdge(int u, int v, int dist) {
    edge[edgeCnt] = Edge(u, v, dist, head[u]);
    head[u] = edgeCnt++;
}

struct Node {
    int u, d;
    bool operator < (const Node& rhs) const {
        return d > rhs.d;
    }
};
int d[maxN];
void Dijstra(int s) {
    priority_queue<Node> q;
    for (int i = 1; i <= N; i++) d[i] = inf;
    d[s] = 0;
    q.push(Node{s, 0});
    while (!q.empty()) {
        Node curr = q.top(); q.pop();
        int u = curr.u;
        if (d[u] < curr.d) continue;
        for (int i = head[u]; i >= 0; i = edge[i].next) {
            Edge e = edge[i];
            if (d[e.to] > d[u] + e.dist) {
                d[e.to] = d[u] + e.dist;
                q.push(Node{e.to, d[e.to]});
            }
        }
    }

}

int main() {

    memset(head, -1, sizeof head);

    scanf("%d %d %d", &N, &A, &B);
    for (int i = 1; i <= N; i++) {
        scanf("%d", &K);
        for (int j = 0; j < K; j++) {
            scanf("%d", &V);
            // i to V need switch
            addEdge(i, V, j == 0 ? 0 : 1);
        }
    }

    Dijstra(A);
    printf("%d\n", d[B] < inf ? d[B] : -1);
    return 0;
}
```

# 20.3.8 LightOJ-1074 Extended Traffic 负边权最短路

n个城市，m条路，每个城市都有一个拥挤度B[i],现在如果我想从城市i到城市j,则拥挤度增加(B[j]-B[i])^3,现在有q次询问，每次询问告诉你一个目的城市t，问你从1出发到t拥挤度增加到最小量是多少。如果增加量小于3或者无法到达，则输出？。

---

首先要明确此题有可能是有负权的，所以需要用spfa而不是Dijstra。既然有负权那么需要考虑是否有负环，否则算法无法停止。但是就算存在负环，对于不在负环上的一些点来说最短路也是同样存在的。所以无需考虑负不负环，直接看d值即可。

```c++
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <queue>

using namespace std;

const int maxN = 205;
const int maxM = maxN * maxN;
const int inf = 0x3f3f3f3f;
int T, n, m, q, value[maxN];

struct Edge{
    int from, to, dist, next;
    Edge() {}
    Edge(int f, int t, int d, int n): from(f), to(t), dist(d), next(n) {}
}edge[maxM];

int edgeCnt = 0, head[maxM];
void addEdge(int u, int v, int dist) {
    edge[edgeCnt] = Edge(u, v, dist, head[u]);
    head[u] = edgeCnt++;
}

struct Node {
    int u, d;
    bool operator < (const Node& rhs) const {
        return d > rhs.d;
    }
};

int inq[maxN], cnt[maxN], d[maxN];

bool spfa(int s) {
    queue<int> q;
    memset(inq, 0, sizeof inq);
    memset(cnt, 0, sizeof cnt);
    for (int i = 1; i <= n; i++) d[i] = inf;
    d[s] = 0;
    q.push(s);
    inq[s] = 1;
    while (!q.empty()) {
        int u = q.front(); q.pop();
        inq[u] = 0;
        for (int i = head[u]; i >= 0; i = edge[i].next) {
            Edge e = edge[i];
            if (d[e.to] > d[u] + e.dist) {
                d[e.to] = d[u] + e.dist;
                if (!inq[e.to]) {
                    q.push(e.to);
                    inq[e.to] = 1;
                    if (++cnt[e.to] > n) return false;
                }
            }
        }
    }
    return true;
}
int calPow(int x) {
    return x * x * x;
}
int main() {
    // freopen("/Users/leey/CLionProjects/cppLearn/input", "r", stdin);
    int kase = 0;
    scanf("%d", &T);
    while (T--) {
        kase++;
        edgeCnt = 0;
        memset(head, -1, sizeof head);
        scanf("%d", &n);
        for (int i = 1; i <= n; i++) scanf("%d", &value[i]);
        scanf("%d", &m);
        for (int i = 0; i < m; i++) {
            int u, v;
            // u->v 有向边 (value[v]-value[u])^3
            scanf("%d %d", &u, &v);
            int d = calPow(value[v]-value[u]);
            addEdge(u, v, d);
        }
        printf("Case %d:\n", kase);
        int res = spfa(1); // 负环的出现？
        scanf("%d", &q);
        for (int i = 0; i < q; i++) {
            int x;
            scanf("%d", &x);
            if (d[x] < 3 || d[x] == inf) {
                printf("?\n");
            } else {
                printf("%d\n", d[x]);
            }
        }

    }

    return 0;
}
```

# 20.3.8 HDU-4725 The Shortest Path in Nya Graph 最短路+建图优化稠密图

n个点，m条无向边，除此之外，告诉你每个点都会在一个层数i(1 <= i <= n)，且相邻层数的点可以互相到达，距离为C。现在问从点1到点N点最短路。

---

初看这是最短路的裸题，但是题目中n和m的范围非常大，有1e5,如果对相邻层之间的点也两两建边点话则边数会非常多，比如相邻两层如果各有n个点那么就有n^2条边。事实证明这种情况交上去会TLE。如何优化呢？我们把每一层都看成一个单独的点x，那么该点x到该层的所有点都延伸出一条有向边，该边权值为0。注意这里是一条边，如果是双向边那么同一层的节点就可以无障碍互通了，这显然是不符合题意的。

那么相邻层数可以到达如何刻画呢？我们把第i层上的点都指向其相邻上下两层的层节点，边权为c。这样，对于每个点最多多出3条边，加上m条边则边最多只有4*n条。把edge数组开得大一些即可。

```c++
#include <cstdio>
#include <cstring>
#include <queue>

using namespace std;
const int inf = 0x3f3f3f3f;
const int maxN = 1e5 + 5;
int T, N, M, C;

struct Edge {
    int from, to, dist, next;
    Edge() {}
    Edge(int f, int t, int d, int n) :from(f), to(t), dist(d), next(n) {}
}edge[10*maxN];
int edgeCnt, head[2*maxN];
void addEdge(int u, int v, int dist) {
    edge[edgeCnt] = Edge(u, v, dist, head[u]);
    head[u] = edgeCnt++;
}

struct Node {
    int u, d;
    bool operator < (const Node &rhs) const {
        return d > rhs.d;
    }
};
int d[2*maxN];

void Dijstra(int s) {
    priority_queue<Node> q;
    for (int i = 1; i <= 2*N; i++) d[i] = inf;
    d[s] = 0;
    q.push(Node{ s, 0 });
    while (!q.empty()) {
        Node curr = q.top(); q.pop();
        int u = curr.u;
        if (d[u] < curr.d) continue;
        for (int i = head[u]; i >= 0; i = edge[i].next) {
            Edge e = edge[i];
            if (d[e.to] > d[u] + e.dist) {
                d[e.to] = d[u] + e.dist;
                q.push(Node{ e.to, d[e.to] });
            }
        }
    }
}


int main() {
    // freopen("/Users/leey/CLionProjects/cppLearn/input", "r", stdin);

    int kase = 0;
    scanf("%d", &T);
    while (T--) {
        kase++;
        scanf("%d %d %d", &N, &M, &C);
        edgeCnt = 0;
        memset(head, -1, sizeof head);
        int u, v, w;

        for (int i = 1; i <= N; i++) {
            scanf("%d", &u);
            addEdge(N+u, i, 0);
            if (u > 1) {
                addEdge(i, N+u-1, C);
                // addEdge(N+u-1, i, C);
            }
            if (u < N) {
                addEdge(i, N+u+1, C);
                // addEdge(N+u+1, i, C);
            }
        }


        for (int i = 0; i < M; i++) {
            scanf("%d %d %d", &u, &v, &w);
            addEdge(u, v, w);
            addEdge(v, u, w);
        }

        Dijstra(1);
        printf("Case #%d: %d\n", kase, d[N] < inf ? d[N] : -1);
    }

    return 0;
}
```

# 20.3.8 HDU-4370 0 or 1 思路+最短路(⭐️⭐️)

给定一个矩阵C，求一个01矩阵X，其满足

```
1.X12+X13+...X1n=1
2.X1n+X2n+...Xn-1n=1
3.for each i (1<i<n), satisfies∑X ki (1<=k<=n)=∑X ij (1<=j<=n).
```

使得矩阵C*X值最小。

---

乍看这个和最短路一点关系没有，要不是在最短路专题下凭我的水平还真不够往最短路方面想。自己看最后求的是C*X，把Cij看成i到j有向边的权值，那么结果求的就是1～n的最短路。为什么这样说？第一个条件说明点1出度为1，第二个条件说明点n入度为1，第三个条件说明对于点i，其入度等于出度。因此1～n点一条路径就刚好满足上述三个性质且其路径和就是答案要求的。

但是，这个条件是否充分？即任意的X矩阵都能看成1～n的最短路？答案是否定的，也正是因为没有考虑这个条件导致WA了好多次。如果从点1有一个闭环，同样点n也有，那么同样符合要求。注意这里闭环的点数至少为2。因此答案应该是这两种情况的最短路的最小值。

如何求闭环的最短路？我们知道在Dijstra中每次出队的元素u的最短路是已经确定的，因此该d值在加上C[u, s]的和就代表是一条点1的闭环。因此在求Dijstra点过程中记录一下闭环的最小值即可。然后再求一下Dijstra(n)，即得到点n点闭环的最小值，两者之和和d[n]的较小者就是我们要的答案。

```c++
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <queue>

using namespace std;

const int inf = 0x3f3f3f3f;
const int maxN = 305;
const int maxM = maxN * maxN;

int n, c;

struct Edge{
    int from, to, dist, next;
    Edge() {}
    Edge(int f, int t, int d, int n):from(f), to(t), dist(d), next(n) {}
}edge[maxM];
int edgeCnt = 0, head[maxN];
void addEdge(int u, int v, int d) {
    edge[edgeCnt] = Edge(u, v, d, head[u]);
    head[u] = edgeCnt++;
}

struct Node{
    int u, d;
    bool operator < (const Node& rhs) const {
        return d > rhs.d;
    }
};
int d[maxN], C[maxN][maxN], dis;
void Dijstra(int s) {
    priority_queue<Node> q;
    for (int i = 1; i <= n; i++) d[i] = inf;
    d[s] = 0;
    dis = inf;
    q.push(Node{s, 0});
    while (!q.empty()) {
        Node curr = q.top(); q.pop();
        int u = curr.u;
        if (d[u] < curr.d) continue;
        // u的最短路已经确定
        if (u != s) {
            // 到s闭环的距离
            dis = min(dis, d[u] + C[u][s]);
        }
        for (int i = head[u]; i >= 0; i = edge[i].next) {
            Edge e = edge[i];
            if (d[e.to] > d[u] + e.dist) {
                d[e.to] = d[u] + e.dist;
                q.push(Node{e.to, d[e.to]});
            }
            // 1不能指向自己
        }
    }
}
int main() {
    // freopen("/Users/leey/CLionProjects/cppLearn/input", "r", stdin);
    while (~scanf("%d", &n)) {
        edgeCnt = 0;
        memset(head, -1, sizeof head);

        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                scanf("%d", &C[i][j]);
                addEdge(i, j, C[i][j]);

            }
        }
        Dijstra(1);
        int ans = d[n], disTmp = dis;
        Dijstra(n);
        // printf("dis = %d, circle1 = %d, circle2 = %d\n", ans, disTmp, dis);
        dis += disTmp;
        printf("%d\n", min(ans, dis));
    }
    return 0;
}
```

