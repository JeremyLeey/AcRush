[toc]

# 单源最短路径Dijstra算法

Dijstra的思想是贪心，每次挑选d值最小的点用于松弛，**因为不存在负权边，所以d值最小的点此时的最短距离已经确定**。比如，此时挑出的最小d值是i，如果有一条路径，经过j最终到达i的最短路更短，那么则有

```C++
d[j] + 新的路径边 > d[i]，但是有d[j] > d[i], 所以新的路径边 < 0, 和无负权边矛盾，因此不成立；
```

```C++
/**
清除所有点标号
d[s] = 0, 其余d[i] = INF;
循环n次{
  在所有未标记的点中,挑选一个d值最小的点x
  给结点x标记
  对于从x出发的所有边,更新d[y] = min(d[y], d[x] + w(x, y));
}
**/

void Dijstra(int s) {
	memset(vis, 0, sizeof vis);
	for (int i = 0; i < n; i++) d[i] = inf;
	d[s] = 0;
	for (int i = 0; i < n; i++) {
		int x, m = inf;
		for (int j = 0; j < n; j++) {
			if (!v[j] && d[j] < m) {
				m = d[j];
				x = j;
			}
		}
		vis[x] = 1;
		for (int j = 0; j < n; j++) {
			d[j] = min(d[j], d[x] + w[x][j]);
		}
	}
}
```

复杂度O(n2),利用优先队列优化可以将复杂度优化到O(mlogn),其中m是边数。极限情况m和n2是同阶的，但大多数情况下图都是稀疏的，m远小于n2。对于稀疏图也常采用邻接链表来存储图。虽然在最短路问题中，每条边只有边权这一个属性，但后面的最大流以及最小费用流中还会出现容量，流量以及费用等属性。所以在这里使用一个称为Edge的结构体，这会让这里的代码与后面的代码在风格上更统一。代码如下：

```C++
struct Edge{
	int from, to, dist;
	Edge(int u, int v, int d): from(u),to(v),dist(d) {}
};

struct Node{
	int d, u;
	bool operaotr < (const Node& rhs) const {
		return d > rhs.d;
	}
};

struct Dijstra {
	int n, m;
	vector<Edge> G[maxn]; //  邻接链表
	bool vis[maxn];
	int d[maxn];
	int p[maxn];
	
	void init(int n) {
		this->n = n;
		for (int i = 0; i < n; i++) G[i].clear();
	}
	
	void addEdge(int u, int v, int dist) {
		// 无向图两边都要push 有向图只有一边
		G[u].push_back(Edge(u, v, dist));
		G[v].push_back(Edge(v, u, dist));
	}
	
  void Dijstra(int s) {
		priority_queue<Node> Q;
		for (int i = 0; i < n; i++) d[i] = INF;
		d[s] = 0;
		memset(vis, 0, sizeof vis);
		Q.push((Node){0, s});
		while (!Q.empty()) {
			Node curr = Q.top(); Q.pop();
			int u = curr.u;
			if (vis[u]) continue; // 可以省去vis的开销，此处判断改成 if (d[u] < cuur.d) continue;
			vis[u] = true;
			for (int i = 0; i < G[u].size(); i++) {
				Edge e = G[u][i];
				if (d[e.to] > d[u] + e.dist) {
					d[e.to] = d[u] + e.dist;
					Q.push((Node){d[e.to], e.to});
				}
			}
		}
	}
};
```

在松弛成功后，需要修改节点e.to的优先级，但STL中的优先队列不提供修改优先级的操作。因此，只能将新元素重新插入优先队列，这样做并不会影响结果的正确性，因为d值小的节点自然会先出队列。为了防止节点的重复扩展，如果发现新取出来的节点曾经已经被访问过vis[u]，应该直接把它扔掉(或者采用注释的方法进行判断)。

# 带负权边的Bellman-Ford算法

当负权存在时，连最短路都不一定存在了。尽管如此，还是有办法在最短路存在的情况下把它求出来。首先，如果最短路存在，则一定存在一个不含环的最短路。这是因为如果该环为正环或零环，则去掉该环能得到更短的路径；如果为负环，则最短路不存在，因为可以绕着负环走无限多次。

类似于Dijstra算法的松弛操作，我们把对图中的每一条边都执行一次```d[v]=min(d[v],d[u]+w(u,v)) ```的判断成为一轮松弛迭代。可以证明，**若图中存在最短距离未确认的顶点，则每一次迭代后至少增加一个已确认顶点**。证明过程如下

```c++
1. 初始情况下，只有起点s的最短距离已经确定;
2. 假设在第一轮迭代后，没有一个顶点的最短距离被确定，即与s相邻的顶点仍处于未确定状态，假设vi是s相邻的顶点之一；
  2.1 那么存在一条由s出发经过另一个相邻顶点vj最终到达vi的路径<s,vj,..,vi>，其距离小于路径<s, vi>;
	2.2 若 j==i,则说明路径<vi,...,vi>为负权回路，与条件矛盾，不成立；
      若 j!=i,同理存在另一条由s出发经过相邻顶点vk最终到达vj的路径<s,vk,...,vj>,其距离小于路径<s, vj>;
			同样更新d[i]为<s,vk,...,vj,...,vi>,该距离小于<s, vi>
  2.3 因为s的相邻顶点个数是有限个，如此往下寻找，则在某一时刻,一定存在一条路径<s,vi,...,vk,...,vj,...,vi>,其距离小于路径<s, vi>,则存在负环，与条件矛盾；
3. 对于任意次迭代后，被确定距离的顶点为集合S，则同理可以证明下一次迭代后，集合S的元素至少增加一个。
```

证明参考：[数据结构（十一）：最短路径(Bellman-Ford算法)](https://www.jianshu.com/p/b876fe9b2338)

因为不含环,最短路最多只经过不算起点的n-1个结点，可以通过n-1轮松弛操作得到。代码如下，假设起点为0

```C++
for (int i = 0; i < n; i++) d[i] = INF;
d[0] = 0;
for (int k = 0; k < n-1; k++) {
	// 迭代n-1次
	for (int i = 0; i < m; i++) {
		// 检查每条边
		int x = u[i], y = v[i];
		if (d[x] < INF) {
			d[y] = min(d[y], d[x]+w[i]); // 松弛
		}
	}
}
```

Bellman-Ford算法同样可以检测负环，即n-1轮迭代之后，如果仍有```d[v] < d[u] + w(u, v)```,那么存在负权回路。可以看到Bellmaxn-Ford算法的时间复杂度为O(VE),其中V为顶点数目，E为边数，对于稠密图来说该算法复杂度较大。因此常用SPFA(Shorest Path Faster Algorithm)来代替Bellman-Ford算法。

# Bellman-Ford优化后的SPFA算法(检测负环)

可以看到BF算法的缺点在于即使某一次迭代更新后已经获得了所有的最短路径，它还是会继续执行接下来的迭代过程。不难发现，起点s到某一个顶点的最短路径的第一条边，必定是s与其邻接点连成的边。所以当我们在第一次松弛后，松弛的边必定包含上述的第一条边。对于最短路径的第二条边我们同理。因此SPFA算法用FIFO队列来代替上面的循环检查，算法思路如下：

```C++
1. 设置一个队列，初始时将s加入队列中。
2. 若队列不为空，弹出队首元素curr，松弛和其邻接点组成的边，并将松弛成功的邻接点入队，若其未在队列中；
3. 重复以上步骤；
```

代码如下

```C++
bool spfa(int s) {
	queue<int> Q;
	memset(inq, 0, sizeof inq); // inq[i]-点i是否在队列中
	memset(cnt, 0, sizeof cnt); // cnt[i]-点i的入队次数
	for (int i = 0; i < n; i++) d[i] = INF;
	d[s] = 0;
	inq[s] = true;
	Q.push(s);
	while (!Q.empty()) {
		int u = Q.front(); Q.pop();
		inq[u] = false;
		for (int i = 0; i < G[u].size(); i++) {
			Edge &e = edges[G[u][i]];
			if (d[u] < INF && d[e.to] > d[u] + e.dist) {
				d[e.to] = d[u] + e.dist;
				p[e.to] = G[u][i];
				if (!inq[e.to]) {
					Q.push(e.to);
					inq[e.to] = true;
					if (++cnt[e.to] > n) {
						return false; // 存在负环
					}
				}
			}
		}
	}
	return true;
}
```

spfa算法同样可以用于判断负环。当存在负环时，则上述循环陷入死循环。我们用一个cnt数组表示节点的入队次数，若一个节点入队次数超过n次，则说明存在负环。可以这么理解，spfa本质上是bfs，入队的时候表明该点被松弛更新，即每次入队则该最短路径边数至少加一，由于不存在负环所以最短路径最多n-1条边，为什么不是>n-1呢？这是因为对于一个点的图来说，n-1的话就会导致被判断为负环，综合考虑为>n。

# 多源最短路径Floyd-Warshall算法

```c++
思想是动态规划：从i到j只经过前k个结点的最短路径为加入第k个节点后是否存在一条从i到k再到j更短的路
d[i][j][k] = max(d[i][j][k-1], d[i][k][k-1] + d[k][j][k-1]);
利用滚动数组优化如下：
for (int k = 0; k < n; k++)
	for (int i = 0; i < n; i++)
		for (int j = 0; j < n; j++) 
			d[i][j] = max(d[i][j], d[i][k] + d[k][i]);
初始化d[i][i]=dis(i,j),若两点间没边则为inf。
```

# 有向图的传递闭包

在有向图中，有时不必关心路径的长度，而只关心两点间是否有通路，则可以用1和0表示连通和不连通。主算法中相应改成

```C++
d[i][j] = d[i][j] || (d[i][k] && d[k][j])
初始化的话若两点间有边则为1，否则为0。
```

# 20.2.24 POJ -2387 Til the Cows Come Home 最短路裸题

```C++
#include <cstdio>
#include <queue>
#include <cstring>
#include <algorithm>

using namespace std;

const int maxn = 1005;
const int inf = 0x3f3f3f3f;

int t, n, m[maxn][maxn];
int d[maxn], vis[maxn];

void Dijstra(int s) {
	for (int i = 1; i <= n; i++) {
		d[i] = inf;
		vis[i] = 0;
	}
	d[s] = 0;
	for (int i = 0; i < n; i++) {
		int p = -1, minp = inf;
		for (int j = 1; j <= n; j++) {
			if (!vis[j] && d[j] < minp) {
				minp = d[j];
				p = j;
			}
		}
		if (p == -1) return;
		vis[p] = 1;
		for (int j = 1; j <= n; j++) {
			d[j] = min(d[j], d[p] + m[p][j]);
		}
	}
}

int main() {
	while (~scanf("%d %d", &t, &n)) {
		for (int i = 1; i <= n; i++) {
			for (int j = 1; j <= n; j++) {
				m[i][j] = inf;
			}
		}
		for (int i = 0; i < t; i++) {
			int u, v, d;
			scanf("%d %d %d", &u, &v, &d);
			// 题目可能会给重复边
			m[u][v] = m[v][u] = min(m[u][v], d);
		}
		Dijstra(n);
		printf("%d\n", d[1]);
	}
}

```

换用邻接链表以及使用优先队列优化

```C++
#include <cstdio>
#include <queue>
#include <cstring>
#include <algorithm>

using namespace std;

const int maxn = 1005;
const int inf = 0x3f3f3f3f;

int t, n;
int d[maxn], vis[maxn];

struct Edge {
	int from, to, dist;
	Edge(int u, int v, int d) : from(u), to(v), dist(d) {}
};

struct Node {
	int d, u;
	bool operator < (const Node& rhs) const {
		return d > rhs.d;
	}
	Node(int d_, int u_) :d(d_), u(u_) {}
};

vector<Edge> G[maxn];

void Dijstra(int s) {
	priority_queue<Node> q;
	for (int i = 1; i <= n; i++) d[i] = inf;
	d[s] = 0;
	memset(vis, 0, sizeof vis);
	q.push(Node(0, s));
	while (!q.empty()) {
		Node curr = q.top(); q.pop();
		int u = curr.u;
		if (vis[u]) continue;
		vis[u] = true;
		for (int i = 0; i < G[u].size(); i++) {
			Edge v = G[u][i];
			if (d[v.to] > d[u] + v.dist) {
				d[v.to] = d[u] + v.dist;
				q.push(Node(d[v.to], v.to));
			}
		}
	}
}

int main() {
	while (~scanf("%d %d", &t, &n)) {
		for (int i = 1; i <= n; i++) G[i].clear();
		for (int i = 0; i < t; i++) {
			int u, v, d;
			scanf("%d %d %d", &u, &v, &d);
			G[u].push_back(Edge(u, v, d));
			G[v].push_back(Edge(v, u, d));
		}
		Dijstra(n);
		printf("%d\n", d[1]);
	}
}
```

# 20.2.24 POJ-2253 Frogger 最大值最小化二分的Floyd传递闭包 or 变形的Dijstra

给你n个点的坐标同时告诉你起点s与终点t,从s到t有很多种路可以走，一条路有很多边组成，记d是一种路中的最大边，求d的最小值。

**方法一**

最大值最小化问题常用二分解决，本题也可以。对边的长度进行二分，对于当前中值m来说，判断从起点s到终点t的可连通性，采用floyd传递闭包即可解决。注意这里的边长最好全部用int处理，直到之后输出时才求其根号。本题我用double变量进行二分，精度选的很小时直接TLE，选得稍微大一点才勉强A过。

```c++
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>

using namespace std;

const int maxn = 205;
const int inf = 0x3f3f3f3f;
int n;
int x[maxn], y[maxn];
int d[maxn][maxn], dis[maxn][maxn];

bool floyd(int m) {

	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= n; j++) {
			d[i][j] = dis[i][j] > m ? 0 : 1;
		}
	}

	for (int k = 1; k <= n; k++) {
		for (int i = 1; i <= n; i++) {
			for (int j = 1; j <= n; j++) {
				d[i][j] = d[i][j] || (d[i][k] && d[k][j]);
				if (d[1][2]) return true;
			}
		}
	}

	return false;
}
int main() {
	// freopen("E://input.txt", "r", stdin);
	int kase = 0;
	while (~scanf("%d", &n) && n) {
		kase++;
		for (int i = 1; i <= n; i++) {
			scanf("%d %d", &x[i], &y[i]);
		}
		for (int i = 1; i <= n; i++) {
			for (int j = 1; j <= n; j++) {
				dis[i][j] = dis[j][i] = (x[i] - x[j])*(x[i] - x[j]) + (y[i] - y[j])*(y[i] - y[j]);
			}
		}

		int l = 0, r = 2000005, m = 0;
		while (r > l) {
			m = (l + r) / 2;
			// 在m距离下判断1和2号点是否连通
			if (floyd(m)) {
				r = m;
			}
			else {
				l = m+1;
			}
		}
		printf("Scenario #%d\n", kase);
		printf("Frog Distance = %.3f\n", sqrt((double)l));
		puts("");
	}
	return 0;
}
```

**方法二**

由于起点终点均已告诉，所以可以直接用Dijstra解决。Dijstra中d[i]的含义则变成从起点s到终点i时不同路径的边的最大值的最小值，起初d[i] = Distance(s, i)。在松弛阶段修改相应条件即可。

```C++
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>

using namespace std;

const int maxn = 205;
const int inf = 0x3f3f3f3f;
int n;
int x[maxn], y[maxn];
int d[maxn];
int dis[maxn][maxn];
int vis[maxn];

int Dijstra(int s) {
	memset(vis, 0, sizeof vis);
	for (int i = 1; i <= n; i++) {
		d[i] = dis[s][i];
	}

	for (int i = 0; i < n; i++) {
		int x, m = inf;
		for (int y = 1; y <= n; y++) {
			if (!vis[y] && d[y] < m) {
				x = y;
				m = d[y];
			}
		}
		vis[x] = 1;
		for (int y = 1; y <= n; y++) {
			// 修改相应松弛条件
			d[y] = min(d[y], max(d[x], dis[x][y]));
		}
	}
	return d[2];
}

int main() {
	// freopen("E://input.txt", "r", stdin);
	int kase = 0;
	while (~scanf("%d", &n) && n) {
		kase++;
		for (int i = 1; i <= n; i++) {
			scanf("%d %d", &x[i], &y[i]);
		}
		for (int i = 1; i <= n; i++) {
			for (int j = 1; j <= n; j++) {
				dis[i][j] = dis[j][i] = (x[i] - x[j])*(x[i] - x[j]) + (y[i] - y[j])*(y[i] - y[j]);
			}
		}
		int l = Dijstra(1);
		printf("Scenario #%d\nFrog Distance = %.3f\n", kase, sqrt((double)l));
		puts("");
	}
	return 0;
}
```

# 20.2.24 POJ 1797 Heavy Transporation 变形Dijstra 

给你n个点，以及m条边，现在问你从点1到点n的不同路线中权重的最小值的最大值。

---

Dijstra的关键在于“松弛”一步，选择一个点进行松弛。我们令d[i]代表从起点到节点i最小权重的最大值，那么松弛一步就可以改为

```
d[v] = max(d[v], min(d[u], w[u][v]))
```

因此队列每次要出来d值最大的那一个，这样才能保证松弛的正确性。最后就是这题每个样例输出结束后都要打一个空行。

````C++
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <queue>

using namespace std;

const int maxn = 1005;
const int inf = 0x3f3f3f3f;
int n, m;

struct Edge{
    int from, to, dist;
    Edge(int u, int v, int d): from(u), to(v), dist(d) {}
};

vector<Edge> G[maxn];
int d[maxn], vis[maxn];

struct Node{
    int u, d;
    bool operator < (const Node &rhs) const {
        return d < rhs.d;
    }
};

int Dijstra(int s) {
    for (int i = 1; i <= n; i++) d[i] = 0;
    d[s] = inf;
    memset(vis, 0, sizeof vis);

    priority_queue<Node> Q;
    Q.push((Node){s, 0});
    while (!Q.empty()) {
        Node curr = Q.top(); Q.pop();
        int u = curr.u;
        if (vis[u]) continue;
        vis[u] = true;
        for (int i = 0; i < G[u].size(); i++) {
            Edge e = G[u][i];
            if (d[e.to] < min(d[u], e.dist) ) {
                d[e.to] = min(d[u], e.dist);
                Q.push((Node){e.to, d[e.to]});
            }
        }
    }
    return d[n];
}

int main() {
    int t, kase = 0;
    scanf("%d", &t);
    while (t--) {
        kase++;
        scanf("%d %d", &n, &m);
        for (int i = 1; i <= n; i++) G[i].clear();

        for (int i = 0; i < m; i++) {
            int u, v, d;
            scanf("%d %d %d", &u, &v, &d);
            G[u].push_back(Edge(u, v, d));
            G[v].push_back(Edge(v, u, d));
        }

        int res = Dijstra(1);
        printf("Scenario #%d:\n", kase);
        printf("%d\n\n", res);
    }
    return 0;
}
````

# 20.2.25 POJ 3268 Sliver Pow Party 多源Dijstra

n个节点的有向图，其中一个给定终点x，然后从其余节点出发到达x然后再从x返回到起点，每趟都要求是最短路，求来回一趟最远的那个。

---

首先这是一个多源但是终点给定的最短路问题，floyd的复杂度为1000^3因此超时。所以采用Dijstra，一种方式是循环n次的Dijstra，另一种正向反向一遍Dijstra即可。有向图的多源最短路把有向、起点、终点颠倒一下就变成单源最短路。颠倒可以采用另一个G存储或者转置一下矩阵。

---

这里我因为push那个地方写成了e.dist而不是d[e.to]一直WA了一个多小时。。。太蠢了！

```C++
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <queue>

using namespace std;

const int maxn = 1005;
const int inf = 0x3f3f3f3f;

int n, m, x;
int d[maxn][2];

struct Edge{
    int from, to, dist, flag;
    Edge(int u, int v, int d, int f): from(u), to(v), dist(d), flag(f) {}
};

struct Node{
    int u, d;
    bool operator < (const Node& rhs) const {
        return d > rhs.d;
    }
};
vector<Edge> G[maxn];

// 从起点s 只走正向边的最短路
void Dijstra(int s, int flag) {
    priority_queue<Node> q;
    q.push((Node){s, 0});
    d[s][0] = d[s][1] = 0;
    while (!q.empty()) {
        Node curr = q.top(); q.pop();
        int u = curr.u;
        if (d[u][flag] < curr.d) continue;
        for (int i = 0; i < G[u].size(); i++) {
            Edge e = G[u][i]; // 区分这条边是正向边还是反向边
            if (e.flag != flag) continue;
            if (d[e.to][flag] > d[u][flag] + e.dist) {
                d[e.to][flag] = d[u][flag] + e.dist;
                q.push((Node){e.to, d[e.to][flag]});
            }
        }

    }
}

int main() {
    while (~scanf("%d %d %d", &n, &m, &x)) {
        for (int i = 1; i <= n; i++) {
            G[i].clear();
            d[i][0] = d[i][1] = inf;
        }

        for (int i = 0; i < m; i++) {
            int u, v, c;
            scanf("%d %d %d", &u, &v, &c);
            G[u].push_back(Edge(u, v, c, 0)); // 正向边
            G[v].push_back(Edge(v, u, c, 1)); // 反向边
        }
        // 多源最短路径问题
        for (int i = 0; i < 2; i++) Dijstra(x, i);
        int ans = 0;
        for (int i = 1; i <= n; i++) {
            if (i != x && d[i][0] < inf && d[i][1] < inf)
                ans = max(ans, d[i][0] + d[i][1]);
        }

        printf("%d\n", ans);

    }
    return 0;
}
```

# 20.2.28 POJ-1860 Currency Exchange SPFA检测负环

给你n种货币，然后告诉你m种交换关系，每次交换按照收取一定的手续费，现在你拥有S货币V个，能否在一些交换之后，成功换回S货币且价值增加。

---

建图。n种货币n个节点，货币之间的转换关系为边。令d[i]表示到达第i个节点时能获得的最大价值，起初d[S]=V,其余d[i]=0。那么则有```d[v] < d[u] + w(u, v)```时进行松弛操作。如何判断能赚？只需判断当u==s时最大价值是否大于初始价值即可。其实也是一个判断该图是否有正环的问题，因为有正环的话就能一直换一直换，总有能赚的时候。

```C++
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <queue>
#include <vector>
using namespace std;

const int maxn = 105;
const int inf = 0x3f3f3f3f;
int N, M, S;
double V;

struct Edge{
    int from, to;
    double rate, comm;
    Edge(int f, int t, double r, double c): from(f), to(t), rate(r), comm(c) {}
};
vector<Edge> G[maxn];
double d[maxn];
bool inq[maxn];

bool spfa() {
    queue<int> q;
    memset(inq, 0, sizeof q); // 是否在队列中
    for (int i = 1; i <= N; i++) d[i] = 0; // 到达该点所能获得的最大钱数
    d[S] = V;
    inq[S] = true;
    q.push(S);
    while (!q.empty()) {
        int u = q.front(); q.pop();
        inq[u] = false;
        if (u == S && d[u] > V) return true;
        for (int i = 0; i < G[u].size(); i++) {
            Edge e = G[u][i];
            double t = (d[u] - e.comm) * e.rate; // 这一次到达e.to所能获得的最大钱数
            if (d[e.to] < t) {
                // 这次交换比上次要赚
                d[e.to] = t;
                if (!inq[e.to]) {
                    q.push(e.to);
                    inq[e.to] = true;
                }
            }
        }
    }
    return false;

}

int main() {
    while (~scanf("%d %d %d %lf", &N, &M, &S, &V)) {
        for (int i = 0; i <= N; i++) G[i].clear();
        int a, b;
        double rateAB, rateBA, comAB, comBA;
        for (int i = 0; i < M; i++) {
            scanf("%d %d %lf %lf %lf %lf", &a, &b, &rateAB, &comAB, &rateBA, &comBA);
            G[a].push_back(Edge(a, b, rateAB, comAB));
            G[b].push_back(Edge(b, a, rateBA, comBA));
        }
        puts(spfa() ? "YES" : "NO");
    }
    return 0;
}
```

这道题建图一直绕歪了，把交换点当成图的节点了，还需要勤加练习。业精于勤荒于嬉。

# 20.2.28 POJ-3259 Wormholes spfa判断负环

带负权的有向图，判断是否存在负环。采用spfa做法的话我随意选择了一个起点，不知道会不会出现图不是连通图的情况。

```C++
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <queue>
#include <vector>

using namespace std;

const int maxn = 505;
const int inf = 0x3f3f3f3f;
int N, M, W;

struct Edge{
    int from, to, dist;
    Edge(int f, int t, int d):from(f), to(t), dist(d) {}
};
vector<Edge> G[maxn];
int inq[maxn], cnt[maxn], d[maxn];

bool spfa(int s) {
    queue<int> q;
    memset(inq, 0, sizeof inq);
    memset(cnt, 0, sizeof cnt);
    for (int i = 1; i <= N; i++) d[i] = inf;
    d[s] = 0;
    q.push(s);
    inq[s] = true;
    while (!q.empty()) {
        int u = q.front(); q.pop();
        inq[u] = false;
        for (int i = 0; i < G[u].size(); i++) {
            Edge e = G[u][i];
            if (d[e.to] > d[u] + e.dist) {
                d[e.to] = d[u] + e.dist;
                if (!inq[e.to]) {
                    q.push(e.to);
                    inq[e.to] = true;
                    if (++cnt[e.to] > N) {
                        return true;
                    }
                }
            }
        }
    }
    return false;
}
int main() {
    int F;
    scanf("%d", &F);
    while (F--) {
        int S, E, T;
        scanf("%d %d %d", &N, &M, &W);
        for (int i = 1; i <= N; i++) G[i].clear();
        for (int i = 1; i <= M; i++) {
            scanf("%d %d %d", &S, &E, &T);
            // bidirectional
            G[S].push_back(Edge(S, E, T));
            G[E].push_back(Edge(E, S, T));
        }

        for (int i = 1; i <= W; i++) {
            scanf("%d %d %d", &S, &E, &T);
            // one way path
            G[S].push_back(Edge(S, E, -T));
        }
        // 起点任意选择即可 该点被孤立？
        puts(spfa(1) ? "YES" : "NO");
    }
    return 0;
}
```

# 20.2.28 POJ-2240 Arbitrage spfa or floyd判断负环

还是给定一些货币的交换关系，问你能够通过交换实现盈利。和POJ-1860很相似的题目，直接可以用spfa水过，但是我发现两年前我就水过这道题，当时是使用floyd计算的，其实floyd也可以用于判断负环，只需要判断自己到自己的最短路径是否小于0不就ok了吗！

```C++
#include <cstdio>
#include <string>
#include <map>
#include <cmath>
#include <algorithm>

using namespace std;
const int e = 1e-8;
map<string, int> hashm;
int n, m;
char c1[100], c2[100];
double ratio, road[35][35], dp[35][35];

void floyd_warshall() {
	for (int k = 0; k < n; k++) {
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < n; j++) {
				dp[i][j] = max(dp[i][j], dp[i][k]*dp[k][j]);
			}
		}
	}
}

int main() {
	//freopen("H://input.txt", "r", stdin);
	int cases = 0;
	while (~scanf("%d", &n)) {
		if (n == 0) break;
		hashm.clear();
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < n; j++) {
				if (i == j) dp[i][j] = 1.0;
				else dp[i][j] = 0.0;
			}
		}
		cases++;
		
		for (int i = 0; i < n; i++) {
			scanf("%s", c1);
			hashm[c1] = i;
		}
		scanf("%d", &m);
		for (int i = 0; i < m; i++) {
			scanf("%s %lf %s", c1, &ratio, c2);
			int u = hashm[c1],  v = hashm[c2];
			dp[u][v] = ratio;
		}
		
		floyd_warshall();
		bool tag = false;
		for (int i = 0; i < n; i++) {
			if (dp[i][i] - 1.0 > e) {
				tag = true;
				break;
			}
		} 
		printf("Case %d: %s\n", cases, tag ? "Yes" : "No");
	}
	return 0;
}

```

