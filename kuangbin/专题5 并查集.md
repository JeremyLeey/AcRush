[toc]

 

# 并查集

并查集即是实现了并和查的一种数据结构。定义root数组表示节点所在子树的根节点，并查集实现了两种操作，即find与merge操作。

```c++
int find(int x) {
	if (root[x] == -1) return x; // 这里用root[x]=-1表示所在子树的根节点为自己
	return root[x] = find(root[x]); // 路径压缩
}

void merge(int u, int v) {
    u = find(u);
    v = find(v);
    if (u != v) {
        root[v] = u;
    }
}
// merge操作还可以用过使用一个rank数组优化，即rank小的子树接在rank大的子树上
// rank初始化为0,当两棵树进行合并时，如果rank相同，则随便选择一棵树的根作为新根合并，rank值+1
// 否则rank小的向大的合并，rank值保持不变。
void merge(int u, v) {
    u = find(u);
    v = find(v);
    if (u != v) {
        if (rank[u] == rank[v]) {
            root[v] = u;
            rank[u]++;
        } else if (rank[u] < rank[v]) {
            root[u] = v;
        } else {
            root[v] = u;
        }
    }
}
```

# 20.4.23 POJ-2236 Wireless Network (★)

告诉你N(<=1001)个基站以及他的坐标，还有一个两个基站可以通信的最大距离D。接下来有若干行询问，询问分为两种，第一种为O p，代表修复基站p，第二种为S p q,代表测试基站p和q是否连通，现在问对于每一次S询问，返回是否连通，连通为SUCCESS，否则为FAIL。需要指出的是A和B可以通信当且仅当A和B可以直接通信或者有一个基站C可以同时和AB通信。

---

当修复一个基站p时，将基站p最大通信半径D内的已修复基站利用并查集merge操作即可，查询操作即find操作检查树根是否相同。

当修复一个基站p时，检查目前为止已经修复的基站列表，当满足距离p在D以内的基站merge即可。

# 20.4.30 POJ-1611 The Suspects 维护并查集大小(★)

n个学生，有m个社团，每个学生可以参加多个社团，现在问和学生0有联系的有多少人，即学生0和学生1在一个社团，学生1和学生2在另一个社团，也可认为学生0和学生2联系。

---

并查集裸题，初始化sz数组表示每个集合所包含元素的个数，然后在merge操作时维护sz数组，sz数组可以使用fill函数初始化为1。

```c++
fill(begin, end, val) // [begin, end)
```

# 20.4.30 HDU-1213 How Many Tables  统计多少集合（★）

统计并查操作之后有多少子树。并查集裸题。

# 20.4.30 HDU 3038 How Many Answers Are Wrong 带权并查集(★★)

## 带权并查集

 带权并查集也就是在表示连接指向关系的边具有了权值，表示某种属性，那么对应的在进行find和merge操作时需要维护对应的权值即可。

```
int find(int x) {
	if (f[x] == -1) return x;
	int t = f[x]; // 记录x的原先父节点
	f[x] = find(t);
	value[x] += value[t];
	return f[x];
}

void merge(int x, int y, int s) {
	int px = find(x);
	int py = find(y);
	if (px != py) {
		f[px] = py;
		vaule[px] = value[y] + s - value[x];
	}
}
// 这里认为py作为新树的根,value[x]为x关于px的权，value[y]为y关于py的权,s为x关于y的权值
// x到py的两条路径权值之和权值相同,因此f[px] = py所表示的关系对应的权值应该按上式计算
```

当然上述权值更新并不是固定的，要具体的根据不同的题意来分析。

---

给定N个数编号为1到N，然后告诉你m个关系，即第i个数到第j个数的和为sum，现在问你有多少个关系是错误的。假设关系从前到后按照顺序。

---

首先明白错误的情况，比如先告诉你了[1, 10]为40，[1, 5]为30， 显然[6, 10] 就应该为10，为其他值时就表示该关系错误。也就是说前两个关系可以确定第三个关系，当你告诉我一个不同的第三个关系时就表示错误。

为了利用并查集表示，我们将区间转化为左开右闭的区间，而区间和则为两端点边的权值。即[1, 11)权值为40，[1, 6)权值为30， 显然可以确定[6, 11)的权值为10，这是因为1, 11, 6属于同一个并查集。而[1,  3）两端并不属于同一端点，所以其区间和不能确定。

```c++
#include <bits/stdc++.h>
using namespace std;

const int maxN = 200005;
int N, M, A, B, S;
int f[maxN], value[maxN];

int ans;

int find(int x) {
	if (f[x] == -1) return x;
	int t = f[x];
	f[x] = find(t);
	value[x] += value[t];
	return f[x];
}

void merge(int x, int y, int s) {
	int px = find(x);
	int py = find(y);
	if (px != py) {
		f[px] = py;
		value[px] = value[y] + s - value[x];
	} else {
		// 两端的关系已经确定
		// value[x] x->root value[y]->root x->y s
		if (value[x] != s + value[y]) {
			ans++;
		}
	}
}

int main() {
	// freopen("E://input.txt", "r", stdin);
	while (~scanf("%d %d", &N, &M)) {
		memset(f, -1, sizeof f);
		memset(value, 0, sizeof value);
		ans = 0;

		for (int i = 0; i < M; i++) {
			scanf("%d %d %d", &A, &B, &S);
			B++;
			merge(A, B, S);
		}
		printf("%d\n", ans);
	}

	return 0;
}
```

# 20.6.15 POJ-1182 食物链 带权并查集 经典题(★★★)

给定ABC三种动物，A吃B，B吃C，C吃A。现在告诉你按顺序告诉你K句话，描述两种动物之间的关系，比如同类或者谁吃谁，现在问你有多少句假话。

---

由于ABC的互吃的顺序，因此由两个相对关系可以推出另一个的绝对关系，比如A吃B，B和C同类，那么A和C的关系就决定了。于是可以用并查集解决，当两个端点处在同一个集合，就是说明他们的关系已经由前面的关系决定，因此只需要比较当前关系是否相同即可。关键在于权的定义，我们定义value数组表示当前节点与其父节点的关系，具体如下

```c++
value[x] = 0, x与f[x]同类
value[x] = 1, x被f[x]吃
value[x] = 2, f[x]吃x
```

因此当x和y已经处于同一集合内部时，只需要检查其当前关系和给定的关系是否矛盾即可。

当x和y处于不同的集合，我们只需要合并两个子树即可，然后更新value即可。

```c++
#include <bits/stdc++.h>
using namespace std;

const int maxN = 50005;

int N, K, D, X, Y, ans;
int f[maxN], value[maxN];

int find(int x) {
	if (f[x] == x) return x;
	int t = f[x];
	f[x] = find(t);
	value[x] = (value[x] + value[t]) % 3; // attention!
	return f[x];
}

void merge(int x, int y, int d) {
	int px = find(x);
	int py = find(y);
	if (px == py) {
		// 关系已经确定,属于同一类
		if (d == 1 && value[x] != value[y]) ans++;
		if (d == 2 && (value[x] + 1) % 3 != value[y]) ans++; // d==2,x吃y,(value[x]+1)%3==y判断
	} else {
		// 将两个节点添加到对应的树当中
		f[py] = px;
        // 注意这里最后+3,因为存在前面这一部分为负数
		value[py] = (value[x] + d - 1 - value[y] + 3) % 3;
	}
}


int main() {
	// freopen("E://input.txt", "r", stdin);
	scanf("%d %d", &N, &K);
	for (int i = 1; i <= N; i++) {
		f[i] = i;
		value[i] = 0;
	}
	ans = 0;
	for (int i = 0; i < K; i++) {
		scanf("%d %d %d", &D, &X, &Y);
		if (X > N || Y > N || (D==2 && X==Y)) {
			ans++;
			continue;
		}
		merge(X, Y, D);

	}
	printf("%d\n", ans);
	return 0;
}
```

# 20.6.15 POJ-1456 Supermarket 贪心+并查集应用(★★)

给定n个商品的价格和期限，每个商品都仅需要一天卖出，问怎么卖可以获得最大利润？

---

为了获得最大利润，价格高的商品一定要先卖的。考虑期限为i的k个商品，现在的问题就变成了这k个商品都可以卖出去吗？维护一个期限d的并查集，对于当前期限d的一个商品，其父节点表示前面空闲的那一天pd,如果pd大于0则表示可以在该天卖该商品，然后pd往前推一天。利用并查集实现在O(1)的时间内快速的访问到其父节点。

实际上并查集的作用有点像动态链表式的感觉。。

```c++
#include <bits/stdc++.h>
using namespace std;

int n, f[10005];
struct Product {
	int p, d;
	bool operator < (const Product &rhs) const {
		return p > rhs.p;
	}
}pro[10005];

int find(int x) {
	if (f[x] == -1) return x;
	return f[x] = find(f[x]);;
}

int main() {
	// freopen("E://input.txt", "r", stdin);
	while (~scanf("%d", &n)) {
		int sum = 0;
		memset(f, -1, sizeof f);
		for (int i = 0; i < n; i++) {
			scanf("%d %d", &pro[i].p, &pro[i].d);
		}
		sort(pro, pro + n);
		for (int i = 0; i < n; i++) {
			int pd = find(pro[i].d);
			if (pd > 0) {
				sum += pro[i].p;
				f[pd] = pd - 1;
			}
		}
		printf("%d\n", sum);
	}
	return 0;
}
```

# 20.6.16 POJ-1733 Parity Game Hash离散化处理+并查集(★★)

给定长度为n的01串，然后告诉你一连串的条件,(起始位置，结束位置，区间和奇偶)，问你第几个条件是和前面的条件矛盾的，这里n最大可达到1e9，条件最多5000

---

根据两个相对关系可以确定另外一对的绝对关系，这是带权并查集的典型应用，本题同样如此。但是由于n非常大，因此并不能直接开这么大的数组，因此需要用离散化即hash进行处理，由于条件最多5000，因此最多出现1e4个数，给每一个出现的数都hash一个sz，那么只需要开一个1e4的数组就能处理。

剩下就是要注意权值的更新改为异或，区间位置要改为一开一闭。

```c++
#include <cstdio>
#include <map>
#include <algorithm>

using namespace std;

const int maxN = 10005;

int n, m, s, e, total;
char ch[10];
map<int, int> dict;

int f[maxN], val[maxN];

void init() {
    memset(f, -1, sizeof f);
    memset(val, 0, sizeof val);
    dict.clear();
    total = 0;
}

int getHash(int x) {
    if (dict.find(x) == dict.end()) dict[x] = ++total;
    return dict[x];
}

int find(int x) {
    if (f[x] == -1) return x;
    int t = f[x];
    f[x] = find(t);
    val[x] ^= val[t];
    return f[x];
}

bool merge(int x, int y, int w) {
    int px = find(x);
    int py = find(y);
    if (px == py) {
        if (val[x] != val[y] ^ w) return false;
    } else {
        f[px] = py;
        val[px] = w ^ val[y] ^ val[x];
    }
    return true;
}
int main() {
    init();
    scanf("%d %d", &n, &m);
    int i = 0;
    for (; i < m; i++) {
        scanf("%d %d %s", &s, &e, ch);
        if (s > e) swap(s, e);
        e++;
        int ss = getHash(s), ee = getHash(e);
        int w = ch[0] == 'e' ? 0 : 1;
        if (!merge(ss, ee, w)) break;
    }
    printf("%d\n", i);
    return 0;
}
```

# 20.6.16 POJ-1984 Navigation Nightmare 带权并查集(★★)

给定n个农场1到n标记，同时顺序告诉你两个农场之间的路的方向和长度，这里路只有东南西北四个方向。然后在这之中有一个人会不断发问两个农场的曼哈顿距离，如果连通就返回对应的曼哈顿距离，否则就返回-1.

---

题目的解决思路还是很清楚的，不过就是先处理一下在一次询问之前将已知的条件全部处理。然后权值的更新采用两个数组即x和y数组表示相对于父节点的坐标。

```c++
#include <bits/stdc++.h>
using namespace std;

const int maxN = 40005;

int n, m, k;
struct Entity{
    int from;
    int to;
    int dis;
    int dir;
    Entity(int f, int t, int d_, char d[]): from(f), to(t), dis(d_) {
        if (d[0] == 'N') dir = 0;
        if (d[0] == 'S') dir = 1;
        if (d[0] == 'W') dir = 2;
        if (d[0] == 'E') dir = 3;
    }
};

struct Query{
    int from;
    int to;
    int idx;
    bool operator < (const Query &q) const {
        return idx < q.idx;
    }
    Query(int f, int t, int i): from(f), to(t), idx(i) {}
};

vector<Entity> entities;
vector<Query> queries;

int f[maxN], x[maxN], y[maxN];

void init() {
    memset(f, -1, sizeof f);
    memset(x, 0, sizeof x);
    memset(y, 0, sizeof y);
    entities.clear();
    queries.clear();
}
int find(int s) {
    if (f[s] == -1) return s;
    int t = f[s];
    f[s] = find(t);
    // update x[s], y[s]
    x[s] += x[t];
    y[s] += y[t];

    return f[s];

}

void merge(int u, int v, int dis, int dir) {
    int pu = find(u);
    int pv = find(v);
    if (pu != pv) {
        f[pu] = pv;
        int dx = 0, dy = 0;
        if (dir == 0) dy = dis;
        if (dir == 1) dy = -dis;
        if (dir == 2) dx = -dis;
        if (dir == 3) dx = dis;
        x[pu] = x[v] + dx - x[u];
        y[pu] = y[v] + dy - y[u];
    }
}

void sol(int u, int v) {
    int pu = find(u);
    int pv = find(v);
    if (pu == pv) {
        printf("%d\n", abs(x[u]-x[v])+abs(y[u]-y[v]));
    } else {
        printf("-1\n");
    }
}
int main() {
    init();
    scanf("%d %d", &n, &m);
    int f, t, d, idx;
    char dir[5];
    for (int i = 0; i < m; i++) {
        scanf("%d %d %d %s", &f, &t, &d, dir);
        entities.push_back(Entity(f, t, d, dir));
    }
    scanf("%d", &k);
    for (int i = 0; i < k; i++) {
        scanf("%d %d %d", &f, &t, &idx);
        queries.push_back(Query(f, t, idx));
    }
    sort(queries.begin(), queries.end());

    int i = 0, j = 0;
    while (i < queries.size()) {
        for (; j < queries[i].idx; j++) {
            Entity e = entities[j];
            // e.from, e.to, e.dis, e.dir
            merge(e.from, e.to, e.dis, e.dir);
        }
        // j == cur.idx
        while (i < queries.size() && queries[i].idx == j) {
            sol(queries[i].from, queries[i].to);
            i++;
        }
    }
    return 0;
}
```

